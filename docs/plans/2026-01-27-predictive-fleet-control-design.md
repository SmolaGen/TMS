# Дизайн-документ: Predictive Fleet Control (Проактивное управление флотом)

**Дата:** 2026-01-27  
**Статус:** Draft/Approved  
**Автор:** Antigravity (AI Architect)

---

## 1. Обзор (Overview)
Система проактивного управления флотом позволяет диспетчеру прогнозировать спрос и предложение в будущем, визуализировать потенциальные дефициты машин и оперативно реагировать на них через маркетинговые и коммуникационные инструменты.

## 2. Цели и задачи
*   **Снижение времени подачи:** За счет предварительного распределения водителей в зоны ожидаемого спроса.
*   **Оптимизация доходов:** Помощь водителям в поиске заказов без лишнего "порожнего" пробега.
*   **Инструментарий диспетчера:** Переход от "тушения пожаров" к планированию.

## 3. Архитектура и компоненты

### 3.1. Frontend (React + Leaflet/Heatmap)
*   **Time Slider Component:** Плавающий контроллер внизу карты для выбора временного смещения (от +0 до +24 часов).
*   **Predictive Heatmap Layer:** Слой, отображающий плотность заказов. Цвета: синий (баланс) -> красный (дефицит).
*   **Action Bubbles (Gap Markers):** Динамические маркеры в центрах зон дефицита. Отображают разницу $\Delta$ (Спрос - Предложение).
*   **Quick Action Popover:** Контекстное меню пузыря с кнопками "Привлечь водителей" (бонусы) и "Отправить совет" (push).

### 3.2. Backend (FastAPI + Analytics Module)
*   **Demand Predictor Service:** Модуль, объединяющий:
    *   `Scheduled Orders`: Реальные заказы в базе с будущим временем старта.
    *   `Demand Patterns`: Таблица исторических весов (день недели, час, зона).
*   **Supply Forecast Service:** Оценка количества водителей, которые будут свободны в данной зоне в целевое время.
*   **API Endpoints:**
    *   `GET /api/v1/analytics/predictive-map`: Возвращает GeoJSON для тепловой карты и метаданные для пузырей.
    *   `POST /api/v1/analytics/dispatch-action`: Запуск коммуникации или активация промо-зоны.

## 4. Потоки данных (Data Flow)
1. Диспетчер передвигает слайдер на `+2 часа`.
2. Фронтенд запрашивает данные у API с параметром `time_offset=120`.
3. Бэкенд вычисляет: 
    * Плотность заказов = (Запланированные заказы + Вероятностный спрос).
    * Дефицит = Плотность - Прогноз свободных водителей.
4. Фронтенд отрисовывает тепловую карту и расставляет пузыри в зонах, где Дефицит > Порога.
5. Диспетчер кликает на пузырь, выбирает "Отправить совет".
6. Бэкенд через `notification_service` рассылает пуши водителям в Telegram.

## 5. Обработка ошибок (Error Handling)
*   **Cold Start:** При отсутствии истории используется только Hard Demand (реальные заказы).
*   **Over-notification:** Ограничение на количество советов одному водителю (не чаще 1 раза в час).
*   **Data Latency:** Отображение времени последнего обновления прогноза.

## 6. Тестирование
*   **Backtesting:** Сравнение прогнозов системы с реальными историческими данными за прошлые периоды.
*   **Integrity Tests:** Проверка корректности рассылки уведомлений только тем водителям, которые находятся в зоне досягаемости.
*   **UI/UX Tests:** Проверка производительности карты при большом количестве слоев.

## 7. Следующие шаги
1. Создание таблицы `demand_patterns` и наполнение начальными данными.
2. Реализация API эндпоинта для тепловой карты.
3. Разработка компонентов слайдера и пузырей во фронтенде.
