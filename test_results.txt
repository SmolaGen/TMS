============================= test session starts ==============================
platform darwin -- Python 3.11.10, pytest-9.0.2, pluggy-1.6.0
rootdir: /Users/alsmolentsev/tms_new
plugins: anyio-4.11.0, asyncio-1.3.0, Faker-37.12.0, cov-7.0.0
asyncio: mode=Mode.STRICT, debug=False, asyncio_default_fixture_loop_scope=None, asyncio_default_test_loop_scope=function
collected 3 items

tests/test_modules_5_10.py FFF                                           [100%]

=================================== FAILURES ===================================
_________________________ test_contractor_create_order _________________________

self = <sqlalchemy.dialects.postgresql.asyncpg.AsyncAdapt_asyncpg_cursor object at 0x119f820e0>
operation = 'SELECT contractors.id, contractors.name, contractors.api_key, contractors.webhook_url, contractors.is_active, contractors.created_at \nFROM contractors \nWHERE contractors.api_key = $1::VARCHAR AND contractors.is_active = true'
parameters = ('test-api-key-123',)

    async def _prepare_and_execute(self, operation, parameters):
        adapt_connection = self._adapt_connection
    
        async with adapt_connection._execute_mutex:
            if not adapt_connection._started:
                await adapt_connection._start_transaction()
    
            if parameters is None:
                parameters = ()
    
            try:
>               prepared_stmt, attributes = await adapt_connection._prepare(
                    operation, self._invalidate_schema_cache_asof
                )

/opt/homebrew/Caskroom/miniconda/base/lib/python3.11/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:526: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <AdaptedConnection <asyncpg.connection.Connection object at 0x119fec8b0>>
operation = 'SELECT contractors.id, contractors.name, contractors.api_key, contractors.webhook_url, contractors.is_active, contractors.created_at \nFROM contractors \nWHERE contractors.api_key = $1::VARCHAR AND contractors.is_active = true'
invalidate_timestamp = 0

    async def _prepare(self, operation, invalidate_timestamp):
        await self._check_type_cache_invalidation(invalidate_timestamp)
    
        cache = self._prepared_statement_cache
        if cache is None:
            prepared_stmt = await self._connection.prepare(
                operation, name=self._prepared_statement_name_func()
            )
            attributes = prepared_stmt.get_attributes()
            return prepared_stmt, attributes
    
        # asyncpg uses a type cache for the "attributes" which seems to go
        # stale independently of the PreparedStatement itself, so place that
        # collection in the cache as well.
        if operation in cache:
            prepared_stmt, attributes, cached_timestamp = cache[operation]
    
            # preparedstatements themselves also go stale for certain DDL
            # changes such as size of a VARCHAR changing, so there is also
            # a cross-connection invalidation timestamp
            if cached_timestamp > invalidate_timestamp:
                return prepared_stmt, attributes
    
>       prepared_stmt = await self._connection.prepare(
            operation, name=self._prepared_statement_name_func()
        )

/opt/homebrew/Caskroom/miniconda/base/lib/python3.11/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:773: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <asyncpg.connection.Connection object at 0x119fec8b0>
query = 'SELECT contractors.id, contractors.name, contractors.api_key, contractors.webhook_url, contractors.is_active, contractors.created_at \nFROM contractors \nWHERE contractors.api_key = $1::VARCHAR AND contractors.is_active = true'

    async def prepare(
        self,
        query,
        *,
        name=None,
        timeout=None,
        record_class=None,
    ):
        """Create a *prepared statement* for the specified query.
    
        :param str query:
            Text of the query to create a prepared statement for.
        :param str name:
            Optional name of the returned prepared statement.  If not
            specified, the name is auto-generated.
        :param float timeout:
            Optional timeout value in seconds.
        :param type record_class:
            If specified, the class to use for records returned by the
            prepared statement.  Must be a subclass of
            :class:`~asyncpg.Record`.  If not specified, a per-connection
            *record_class* is used.
    
        :return:
            A :class:`~prepared_stmt.PreparedStatement` instance.
    
        .. versionchanged:: 0.22.0
            Added the *record_class* parameter.
    
        .. versionchanged:: 0.25.0
            Added the *name* parameter.
        """
>       return await self._prepare(
            query,
            name=name,
            timeout=timeout,
            use_cache=False,
            record_class=record_class,
        )

/opt/homebrew/Caskroom/miniconda/base/lib/python3.11/site-packages/asyncpg/connection.py:636: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <asyncpg.connection.Connection object at 0x119fec8b0>
query = 'SELECT contractors.id, contractors.name, contractors.api_key, contractors.webhook_url, contractors.is_active, contractors.created_at \nFROM contractors \nWHERE contractors.api_key = $1::VARCHAR AND contractors.is_active = true'

    async def _prepare(
        self,
        query,
        *,
        name=None,
        timeout=None,
        use_cache: bool=False,
        record_class=None
    ):
        self._check_open()
>       stmt = await self._get_statement(
            query,
            timeout,
            named=True if name is None else name,
            use_cache=use_cache,
            record_class=record_class,
        )

/opt/homebrew/Caskroom/miniconda/base/lib/python3.11/site-packages/asyncpg/connection.py:654: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <asyncpg.connection.Connection object at 0x119fec8b0>
query = 'SELECT contractors.id, contractors.name, contractors.api_key, contractors.webhook_url, contractors.is_active, contractors.created_at \nFROM contractors \nWHERE contractors.api_key = $1::VARCHAR AND contractors.is_active = true'
timeout = None

    async def _get_statement(
        self,
        query,
        timeout,
        *,
        named=False,
        use_cache=True,
        ignore_custom_codec=False,
        record_class=None
    ):
        if record_class is None:
            record_class = self._protocol.get_record_class()
        else:
            _check_record_class(record_class)
    
        if use_cache:
            statement = self._stmt_cache.get(
                (query, record_class, ignore_custom_codec)
            )
            if statement is not None:
                return statement
    
            # Only use the cache when:
            #  * `statement_cache_size` is greater than 0;
            #  * query size is less than `max_cacheable_statement_size`.
            use_cache = (
                self._stmt_cache_enabled
                and (
                    not self._config.max_cacheable_statement_size
                    or len(query) <= self._config.max_cacheable_statement_size
                )
            )
    
        if isinstance(named, str):
            stmt_name = named
        elif use_cache or named:
            stmt_name = self._get_unique_id('stmt')
        else:
            stmt_name = ''
    
>       statement = await self._protocol.prepare(
            stmt_name,
            query,
            timeout,
            record_class=record_class,
            ignore_custom_codec=ignore_custom_codec,
        )

/opt/homebrew/Caskroom/miniconda/base/lib/python3.11/site-packages/asyncpg/connection.py:433: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   asyncpg.exceptions.UndefinedTableError: relation "contractors" does not exist

asyncpg/protocol/protocol.pyx:166: UndefinedTableError

The above exception was the direct cause of the following exception:

self = <sqlalchemy.engine.base.Connection object at 0x119fe44d0>
dialect = <sqlalchemy.dialects.postgresql.asyncpg.PGDialect_asyncpg object at 0x10897ef10>
context = <sqlalchemy.dialects.postgresql.asyncpg.PGExecutionContext_asyncpg object at 0x119fe6810>
statement = <sqlalchemy.dialects.postgresql.asyncpg.PGCompiler_asyncpg object at 0x119fe6890>
parameters = [('test-api-key-123',)]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

/opt/homebrew/Caskroom/miniconda/base/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1967: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.asyncpg.PGDialect_asyncpg object at 0x10897ef10>
cursor = <sqlalchemy.dialects.postgresql.asyncpg.AsyncAdapt_asyncpg_cursor object at 0x119f820e0>
statement = 'SELECT contractors.id, contractors.name, contractors.api_key, contractors.webhook_url, contractors.is_active, contractors.created_at \nFROM contractors \nWHERE contractors.api_key = $1::VARCHAR AND contractors.is_active = true'
parameters = ('test-api-key-123',)
context = <sqlalchemy.dialects.postgresql.asyncpg.PGExecutionContext_asyncpg object at 0x119fe6810>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)

/opt/homebrew/Caskroom/miniconda/base/lib/python3.11/site-packages/sqlalchemy/engine/default.py:952: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.asyncpg.AsyncAdapt_asyncpg_cursor object at 0x119f820e0>
operation = 'SELECT contractors.id, contractors.name, contractors.api_key, contractors.webhook_url, contractors.is_active, contractors.created_at \nFROM contractors \nWHERE contractors.api_key = $1::VARCHAR AND contractors.is_active = true'
parameters = ('test-api-key-123',)

    def execute(self, operation, parameters=None):
>       self._adapt_connection.await_(
            self._prepare_and_execute(operation, parameters)
        )

/opt/homebrew/Caskroom/miniconda/base/lib/python3.11/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:585: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

awaitable = <coroutine object AsyncAdapt_asyncpg_cursor._prepare_and_execute at 0x119f12440>

    def await_only(awaitable: Awaitable[_T]) -> _T:
        """Awaits an async function in a sync method.
    
        The sync method must be inside a :func:`greenlet_spawn` context.
        :func:`await_only` calls cannot be nested.
    
        :param awaitable: The coroutine to call.
    
        """
        # this is called in the context greenlet while running fn
        current = getcurrent()
        if not getattr(current, "__sqlalchemy_greenlet_provider__", False):
            _safe_cancel_awaitable(awaitable)
    
            raise exc.MissingGreenlet(
                "greenlet_spawn has not been called; can't call await_only() "
                "here. Was IO attempted in an unexpected place?"
            )
    
        # returns the control to the driver greenlet passing it
        # a coroutine to run. Once the awaitable is done, the driver greenlet
        # switches back to this greenlet with the result of awaitable that is
        # then returned to the caller (or raised as error)
>       return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/opt/homebrew/Caskroom/miniconda/base/lib/python3.11/site-packages/sqlalchemy/util/_concurrency_py3k.py:132: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <bound method Session.execute of <sqlalchemy.orm.session.Session object at 0x119fd7f10>>
_require_await = False
args = (<sqlalchemy.sql.selectable.Select object at 0x119fe4210>,)
kwargs = {'bind_arguments': None, 'execution_options': immutabledict({'prebuffer_rows': True}), 'params': None}
context = <_AsyncIoGreenlet object at 0x119fe4280 (otid=0x1069dacd0) dead>
switch_occurred = True
result = <coroutine object AsyncAdapt_asyncpg_cursor._prepare_and_execute at 0x119f12440>
value = None

    async def greenlet_spawn(
        fn: Callable[..., _T],
        *args: Any,
        _require_await: bool = False,
        **kwargs: Any,
    ) -> _T:
        """Runs a sync function ``fn`` in a new greenlet.
    
        The sync function can then use :func:`await_only` to wait for async
        functions.
    
        :param fn: The sync callable to call.
        :param \\*args: Positional arguments to pass to the ``fn`` callable.
        :param \\*\\*kwargs: Keyword arguments to pass to the ``fn`` callable.
        """
    
        result: Any
        context = _AsyncIoGreenlet(fn, getcurrent())
        # runs the function synchronously in gl greenlet. If the execution
        # is interrupted by await_only, context is not dead and result is a
        # coroutine to wait. If the context is dead the function has
        # returned, and its result can be returned.
        switch_occurred = False
        result = context.switch(*args, **kwargs)
        while not context.dead:
            switch_occurred = True
            try:
                # wait for a coroutine from await_only and then return its
                # result back to it.
>               value = await result
                        ^^^^^^^^^^^^

/opt/homebrew/Caskroom/miniconda/base/lib/python3.11/site-packages/sqlalchemy/util/_concurrency_py3k.py:196: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.asyncpg.AsyncAdapt_asyncpg_cursor object at 0x119f820e0>
operation = 'SELECT contractors.id, contractors.name, contractors.api_key, contractors.webhook_url, contractors.is_active, contractors.created_at \nFROM contractors \nWHERE contractors.api_key = $1::VARCHAR AND contractors.is_active = true'
parameters = ('test-api-key-123',)

    async def _prepare_and_execute(self, operation, parameters):
        adapt_connection = self._adapt_connection
    
        async with adapt_connection._execute_mutex:
            if not adapt_connection._started:
                await adapt_connection._start_transaction()
    
            if parameters is None:
                parameters = ()
    
            try:
                prepared_stmt, attributes = await adapt_connection._prepare(
                    operation, self._invalidate_schema_cache_asof
                )
    
                if attributes:
                    self.description = [
                        (
                            attr.name,
                            attr.type.oid,
                            None,
                            None,
                            None,
                            None,
                            None,
                        )
                        for attr in attributes
                    ]
                else:
                    self.description = None
    
                if self.server_side:
                    self._cursor = await prepared_stmt.cursor(*parameters)
                    self.rowcount = -1
                else:
                    self._rows = deque(await prepared_stmt.fetch(*parameters))
                    status = prepared_stmt.get_statusmsg()
    
                    reg = re.match(
                        r"(?:SELECT|UPDATE|DELETE|INSERT \d+) (\d+)",
                        status or "",
                    )
                    if reg:
                        self.rowcount = int(reg.group(1))
                    else:
                        self.rowcount = -1
    
            except Exception as error:
>               self._handle_exception(error)

/opt/homebrew/Caskroom/miniconda/base/lib/python3.11/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:563: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.asyncpg.AsyncAdapt_asyncpg_cursor object at 0x119f820e0>
error = UndefinedTableError('relation "contractors" does not exist')

    def _handle_exception(self, error):
>       self._adapt_connection._handle_exception(error)

/opt/homebrew/Caskroom/miniconda/base/lib/python3.11/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:513: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <AdaptedConnection <asyncpg.connection.Connection object at 0x119fec8b0>>
error = UndefinedTableError('relation "contractors" does not exist')

    def _handle_exception(self, error):
        if self._connection.is_closed():
            self._transaction = None
            self._started = False
    
        if not isinstance(error, AsyncAdapt_asyncpg_dbapi.Error):
            exception_mapping = self.dbapi._asyncpg_error_translate
    
            for super_ in type(error).__mro__:
                if super_ in exception_mapping:
                    translated_error = exception_mapping[super_](
                        "%s: %s" % (type(error), error)
                    )
                    translated_error.pgcode = translated_error.sqlstate = (
                        getattr(error, "sqlstate", None)
                    )
>                   raise translated_error from error
E                   sqlalchemy.dialects.postgresql.asyncpg.AsyncAdapt_asyncpg_dbapi.ProgrammingError: <class 'asyncpg.exceptions.UndefinedTableError'>: relation "contractors" does not exist

/opt/homebrew/Caskroom/miniconda/base/lib/python3.11/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:797: ProgrammingError

The above exception was the direct cause of the following exception:

client = <httpx.AsyncClient object at 0x119892f10>
test_contractor = <Contractor(id=1, name='Test Contractor')>
session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x119f41b50>

    @pytest.mark.asyncio
    async def test_contractor_create_order(client: AsyncClient, test_contractor: Contractor, session: AsyncSession):
        """Тест создания заказа через Contractor API."""
        data = {
            "orders": [
                {
                    "external_id": "ext_123",
                    "pickup_address": "Москва, Ленина 1",
                    "pickup_lat": 55.75,
                    "pickup_lon": 37.62,
                    "dropoff_address": "Москва, Мира 10",
                    "dropoff_lat": 55.80,
                    "dropoff_lon": 37.70,
                    "time_start": (datetime.now() + timedelta(hours=2)).isoformat(),
                    "priority": "normal",
                    "customer_name": "Ivan",
                    "comment": "Fragile"
                }
            ]
        }
    
        headers = {"X-API-Key": "test-api-key-123"}
>       response = await client.post("/api/v1/contractors/orders", json=data, headers=headers)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_modules_5_10.py:50: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <httpx.AsyncClient object at 0x119892f10>
url = '/api/v1/contractors/orders'

    async def post(
        self,
        url: URL | str,
        *,
        content: RequestContent | None = None,
        data: RequestData | None = None,
        files: RequestFiles | None = None,
        json: typing.Any | None = None,
        params: QueryParamTypes | None = None,
        headers: HeaderTypes | None = None,
        cookies: CookieTypes | None = None,
        auth: AuthTypes | UseClientDefault = USE_CLIENT_DEFAULT,
        follow_redirects: bool | UseClientDefault = USE_CLIENT_DEFAULT,
        timeout: TimeoutTypes | UseClientDefault = USE_CLIENT_DEFAULT,
        extensions: RequestExtensions | None = None,
    ) -> Response:
        """
        Send a `POST` request.
    
        **Parameters**: See `httpx.request`.
        """
>       return await self.request(
            "POST",
            url,
            content=content,
            data=data,
            files=files,
            json=json,
            params=params,
            headers=headers,
            cookies=cookies,
            auth=auth,
            follow_redirects=follow_redirects,
            timeout=timeout,
            extensions=extensions,
        )

/opt/homebrew/Caskroom/miniconda/base/lib/python3.11/site-packages/httpx/_client.py:1859: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <httpx.AsyncClient object at 0x119892f10>, method = 'POST'
url = '/api/v1/contractors/orders'

    async def request(
        self,
        method: str,
        url: URL | str,
        *,
        content: RequestContent | None = None,
        data: RequestData | None = None,
        files: RequestFiles | None = None,
        json: typing.Any | None = None,
        params: QueryParamTypes | None = None,
        headers: HeaderTypes | None = None,
        cookies: CookieTypes | None = None,
        auth: AuthTypes | UseClientDefault | None = USE_CLIENT_DEFAULT,
        follow_redirects: bool | UseClientDefault = USE_CLIENT_DEFAULT,
        timeout: TimeoutTypes | UseClientDefault = USE_CLIENT_DEFAULT,
        extensions: RequestExtensions | None = None,
    ) -> Response:
        """
        Build and send a request.
    
        Equivalent to:
    
        ```python
        request = client.build_request(...)
        response = await client.send(request, ...)
        ```
    
        See `AsyncClient.build_request()`, `AsyncClient.send()`
        and [Merging of configuration][0] for how the various parameters
        are merged with client-level configuration.
    
        [0]: /advanced/clients/#merging-of-configuration
        """
    
        if cookies is not None:  # pragma: no cover
            message = (
                "Setting per-request cookies=<...> is being deprecated, because "
                "the expected behaviour on cookie persistence is ambiguous. Set "
                "cookies directly on the client instance instead."
            )
            warnings.warn(message, DeprecationWarning, stacklevel=2)
    
        request = self.build_request(
            method=method,
            url=url,
            content=content,
            data=data,
            files=files,
            json=json,
            params=params,
            headers=headers,
            cookies=cookies,
            timeout=timeout,
            extensions=extensions,
        )
>       return await self.send(request, auth=auth, follow_redirects=follow_redirects)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/opt/homebrew/Caskroom/miniconda/base/lib/python3.11/site-packages/httpx/_client.py:1540: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <httpx.AsyncClient object at 0x119892f10>
request = <Request('POST', 'http://test/api/v1/contractors/orders')>

    async def send(
        self,
        request: Request,
        *,
        stream: bool = False,
        auth: AuthTypes | UseClientDefault | None = USE_CLIENT_DEFAULT,
        follow_redirects: bool | UseClientDefault = USE_CLIENT_DEFAULT,
    ) -> Response:
        """
        Send a request.
    
        The request is sent as-is, unmodified.
    
        Typically you'll want to build one with `AsyncClient.build_request()`
        so that any client-level configuration is merged into the request,
        but passing an explicit `httpx.Request()` is supported as well.
    
        See also: [Request instances][0]
    
        [0]: /advanced/clients/#request-instances
        """
        if self._state == ClientState.CLOSED:
            raise RuntimeError("Cannot send a request, as the client has been closed.")
    
        self._state = ClientState.OPENED
        follow_redirects = (
            self.follow_redirects
            if isinstance(follow_redirects, UseClientDefault)
            else follow_redirects
        )
    
        self._set_timeout(request)
    
        auth = self._build_request_auth(request, auth)
    
>       response = await self._send_handling_auth(
            request,
            auth=auth,
            follow_redirects=follow_redirects,
            history=[],
        )

/opt/homebrew/Caskroom/miniconda/base/lib/python3.11/site-packages/httpx/_client.py:1629: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <httpx.AsyncClient object at 0x119892f10>
request = <Request('POST', 'http://test/api/v1/contractors/orders')>
auth = <httpx.Auth object at 0x1198a94d0>, follow_redirects = False
history = []

    async def _send_handling_auth(
        self,
        request: Request,
        auth: Auth,
        follow_redirects: bool,
        history: list[Response],
    ) -> Response:
        auth_flow = auth.async_auth_flow(request)
        try:
            request = await auth_flow.__anext__()
    
            while True:
>               response = await self._send_handling_redirects(
                    request,
                    follow_redirects=follow_redirects,
                    history=history,
                )

/opt/homebrew/Caskroom/miniconda/base/lib/python3.11/site-packages/httpx/_client.py:1657: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <httpx.AsyncClient object at 0x119892f10>
request = <Request('POST', 'http://test/api/v1/contractors/orders')>
follow_redirects = False, history = []

    async def _send_handling_redirects(
        self,
        request: Request,
        follow_redirects: bool,
        history: list[Response],
    ) -> Response:
        while True:
            if len(history) > self.max_redirects:
                raise TooManyRedirects(
                    "Exceeded maximum allowed redirects.", request=request
                )
    
            for hook in self._event_hooks["request"]:
                await hook(request)
    
>           response = await self._send_single_request(request)
                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/opt/homebrew/Caskroom/miniconda/base/lib/python3.11/site-packages/httpx/_client.py:1694: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <httpx.AsyncClient object at 0x119892f10>
request = <Request('POST', 'http://test/api/v1/contractors/orders')>

    async def _send_single_request(self, request: Request) -> Response:
        """
        Sends a single request, without handling any redirections.
        """
        transport = self._transport_for_url(request.url)
        start = time.perf_counter()
    
        if not isinstance(request.stream, AsyncByteStream):
            raise RuntimeError(
                "Attempted to send an sync request with an AsyncClient instance."
            )
    
        with request_context(request=request):
>           response = await transport.handle_async_request(request)
                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/opt/homebrew/Caskroom/miniconda/base/lib/python3.11/site-packages/httpx/_client.py:1730: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <httpx.ASGITransport object at 0x119cc9210>
request = <Request('POST', 'http://test/api/v1/contractors/orders')>

    async def handle_async_request(
        self,
        request: Request,
    ) -> Response:
        assert isinstance(request.stream, AsyncByteStream)
    
        # ASGI scope.
        scope = {
            "type": "http",
            "asgi": {"version": "3.0"},
            "http_version": "1.1",
            "method": request.method,
            "headers": [(k.lower(), v) for (k, v) in request.headers.raw],
            "scheme": request.url.scheme,
            "path": request.url.path,
            "raw_path": request.url.raw_path.split(b"?")[0],
            "query_string": request.url.query,
            "server": (request.url.host, request.url.port),
            "client": self.client,
            "root_path": self.root_path,
        }
    
        # Request.
        request_body_chunks = request.stream.__aiter__()
        request_complete = False
    
        # Response.
        status_code = None
        response_headers = None
        body_parts = []
        response_started = False
        response_complete = create_event()
    
        # ASGI callables.
    
        async def receive() -> dict[str, typing.Any]:
            nonlocal request_complete
    
            if request_complete:
                await response_complete.wait()
                return {"type": "http.disconnect"}
    
            try:
                body = await request_body_chunks.__anext__()
            except StopAsyncIteration:
                request_complete = True
                return {"type": "http.request", "body": b"", "more_body": False}
            return {"type": "http.request", "body": body, "more_body": True}
    
        async def send(message: typing.MutableMapping[str, typing.Any]) -> None:
            nonlocal status_code, response_headers, response_started
    
            if message["type"] == "http.response.start":
                assert not response_started
    
                status_code = message["status"]
                response_headers = message.get("headers", [])
                response_started = True
    
            elif message["type"] == "http.response.body":
                assert not response_complete.is_set()
                body = message.get("body", b"")
                more_body = message.get("more_body", False)
    
                if body and request.method != "HEAD":
                    body_parts.append(body)
    
                if not more_body:
                    response_complete.set()
    
        try:
>           await self.app(scope, receive, send)

/opt/homebrew/Caskroom/miniconda/base/lib/python3.11/site-packages/httpx/_transports/asgi.py:170: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <fastapi.applications.FastAPI object at 0x119bf5710>
scope = {'app': <fastapi.applications.FastAPI object at 0x119bf5710>, 'asgi': {'version': '3.0'}, 'client': ('127.0.0.1', 123), 'endpoint': <function create_orders_batch at 0x1191c7380>, ...}
receive = <function ASGITransport.handle_async_request.<locals>.receive at 0x119cc54e0>
send = <function ASGITransport.handle_async_request.<locals>.send at 0x119f1af20>

    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:
        if self.root_path:
            scope["root_path"] = self.root_path
>       await super().__call__(scope, receive, send)

/opt/homebrew/Caskroom/miniconda/base/lib/python3.11/site-packages/fastapi/applications.py:1054: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <fastapi.applications.FastAPI object at 0x119bf5710>
scope = {'app': <fastapi.applications.FastAPI object at 0x119bf5710>, 'asgi': {'version': '3.0'}, 'client': ('127.0.0.1', 123), 'endpoint': <function create_orders_batch at 0x1191c7380>, ...}
receive = <function ASGITransport.handle_async_request.<locals>.receive at 0x119cc54e0>
send = <function ASGITransport.handle_async_request.<locals>.send at 0x119f1af20>

    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:
        scope["app"] = self
        if self.middleware_stack is None:
            self.middleware_stack = self.build_middleware_stack()
>       await self.middleware_stack(scope, receive, send)

/opt/homebrew/Caskroom/miniconda/base/lib/python3.11/site-packages/starlette/applications.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <starlette.middleware.errors.ServerErrorMiddleware object at 0x119fd7110>
scope = {'app': <fastapi.applications.FastAPI object at 0x119bf5710>, 'asgi': {'version': '3.0'}, 'client': ('127.0.0.1', 123), 'endpoint': <function create_orders_batch at 0x1191c7380>, ...}
receive = <function ASGITransport.handle_async_request.<locals>.receive at 0x119cc54e0>
send = <function ASGITransport.handle_async_request.<locals>.send at 0x119f1af20>

    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:
        if scope["type"] != "http":
            await self.app(scope, receive, send)
            return
    
        response_started = False
    
        async def _send(message: Message) -> None:
            nonlocal response_started, send
    
            if message["type"] == "http.response.start":
                response_started = True
            await send(message)
    
        try:
            await self.app(scope, receive, _send)
        except Exception as exc:
            request = Request(scope)
            if self.debug:
                # In debug mode, return traceback responses.
                response = self.debug_response(request, exc)
            elif self.handler is None:
                # Use our default 500 error handler.
                response = self.error_response(request, exc)
            else:
                # Use an installed 500 error handler.
                if is_async_callable(self.handler):
                    response = await self.handler(request, exc)
                else:
                    response = await run_in_threadpool(self.handler, request, exc)
    
            if not response_started:
                await response(scope, receive, send)
    
            # We always continue to raise the exception.
            # This allows servers to log the error, or allows test clients
            # to optionally raise the error within the test case.
>           raise exc

/opt/homebrew/Caskroom/miniconda/base/lib/python3.11/site-packages/starlette/middleware/errors.py:186: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <starlette.middleware.errors.ServerErrorMiddleware object at 0x119fd7110>
scope = {'app': <fastapi.applications.FastAPI object at 0x119bf5710>, 'asgi': {'version': '3.0'}, 'client': ('127.0.0.1', 123), 'endpoint': <function create_orders_batch at 0x1191c7380>, ...}
receive = <function ASGITransport.handle_async_request.<locals>.receive at 0x119cc54e0>
send = <function ASGITransport.handle_async_request.<locals>.send at 0x119f1af20>

    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:
        if scope["type"] != "http":
            await self.app(scope, receive, send)
            return
    
        response_started = False
    
        async def _send(message: Message) -> None:
            nonlocal response_started, send
    
            if message["type"] == "http.response.start":
                response_started = True
            await send(message)
    
        try:
>           await self.app(scope, receive, _send)

/opt/homebrew/Caskroom/miniconda/base/lib/python3.11/site-packages/starlette/middleware/errors.py:164: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.core.middleware.CorrelationIdMiddleware object at 0x119fd6f10>
scope = {'app': <fastapi.applications.FastAPI object at 0x119bf5710>, 'asgi': {'version': '3.0'}, 'client': ('127.0.0.1', 123), 'endpoint': <function create_orders_batch at 0x1191c7380>, ...}
receive = <function ASGITransport.handle_async_request.<locals>.receive at 0x119cc54e0>
send = <function ServerErrorMiddleware.__call__.<locals>._send at 0x119f1be20>

    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:
        if scope["type"] not in ("http", "websocket"):
            await self.app(scope, receive, send)
            return
    
        # Извлекаем Correlation ID из заголовков
        correlation_id = None
        for key, value in scope.get("headers", []):
            if key == self.header_key:
                correlation_id = value.decode("latin-1")
                break
    
        if not correlation_id:
            correlation_id = str(uuid4())
    
        # Привязываем ID к контексту structlog
        structlog.contextvars.bind_contextvars(correlation_id=correlation_id)
    
        if scope["type"] == "http":
            structlog.contextvars.bind_contextvars(
                method=scope["method"],
                path=scope["path"],
            )
    
        async def send_wrapper(message):
            if message["type"] == "http.response.start":
                # Добавляем ID в заголовки HTTP ответа
                headers = list(message.get("headers", []))
                headers.append((self.header_key, correlation_id.encode("latin-1")))
                message["headers"] = headers
            await send(message)
    
        try:
            if scope["type"] == "http":
>               await self.app(scope, receive, send_wrapper)

src/core/middleware.py:50: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <starlette.middleware.cors.CORSMiddleware object at 0x119fd6e90>
scope = {'app': <fastapi.applications.FastAPI object at 0x119bf5710>, 'asgi': {'version': '3.0'}, 'client': ('127.0.0.1', 123), 'endpoint': <function create_orders_batch at 0x1191c7380>, ...}
receive = <function ASGITransport.handle_async_request.<locals>.receive at 0x119cc54e0>
send = <function CorrelationIdMiddleware.__call__.<locals>.send_wrapper at 0x119f9d260>

    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:
        if scope["type"] != "http":  # pragma: no cover
            await self.app(scope, receive, send)
            return
    
        method = scope["method"]
        headers = Headers(scope=scope)
        origin = headers.get("origin")
    
        if origin is None:
>           await self.app(scope, receive, send)

/opt/homebrew/Caskroom/miniconda/base/lib/python3.11/site-packages/starlette/middleware/cors.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <starlette.middleware.exceptions.ExceptionMiddleware object at 0x119fd6e50>
scope = {'app': <fastapi.applications.FastAPI object at 0x119bf5710>, 'asgi': {'version': '3.0'}, 'client': ('127.0.0.1', 123), 'endpoint': <function create_orders_batch at 0x1191c7380>, ...}
receive = <function ASGITransport.handle_async_request.<locals>.receive at 0x119cc54e0>
send = <function CorrelationIdMiddleware.__call__.<locals>.send_wrapper at 0x119f9d260>

    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:
        if scope["type"] not in ("http", "websocket"):
            await self.app(scope, receive, send)
            return
    
        scope["starlette.exception_handlers"] = (
            self._exception_handlers,
            self._status_handlers,
        )
    
        conn: Request | WebSocket
        if scope["type"] == "http":
            conn = Request(scope, receive, send)
        else:
            conn = WebSocket(scope, receive, send)
    
>       await wrap_app_handling_exceptions(self.app, conn)(scope, receive, send)

/opt/homebrew/Caskroom/miniconda/base/lib/python3.11/site-packages/starlette/middleware/exceptions.py:65: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

scope = {'app': <fastapi.applications.FastAPI object at 0x119bf5710>, 'asgi': {'version': '3.0'}, 'client': ('127.0.0.1', 123), 'endpoint': <function create_orders_batch at 0x1191c7380>, ...}
receive = <function ASGITransport.handle_async_request.<locals>.receive at 0x119cc54e0>
send = <function CorrelationIdMiddleware.__call__.<locals>.send_wrapper at 0x119f9d260>

    async def wrapped_app(scope: Scope, receive: Receive, send: Send) -> None:
        response_started = False
    
        async def sender(message: Message) -> None:
            nonlocal response_started
    
            if message["type"] == "http.response.start":
                response_started = True
            await send(message)
    
        try:
            await app(scope, receive, sender)
        except Exception as exc:
            handler = None
    
            if isinstance(exc, HTTPException):
                handler = status_handlers.get(exc.status_code)
    
            if handler is None:
                handler = _lookup_exception_handler(exception_handlers, exc)
    
            if handler is None:
>               raise exc

/opt/homebrew/Caskroom/miniconda/base/lib/python3.11/site-packages/starlette/_exception_handler.py:64: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

scope = {'app': <fastapi.applications.FastAPI object at 0x119bf5710>, 'asgi': {'version': '3.0'}, 'client': ('127.0.0.1', 123), 'endpoint': <function create_orders_batch at 0x1191c7380>, ...}
receive = <function ASGITransport.handle_async_request.<locals>.receive at 0x119cc54e0>
send = <function CorrelationIdMiddleware.__call__.<locals>.send_wrapper at 0x119f9d260>

    async def wrapped_app(scope: Scope, receive: Receive, send: Send) -> None:
        response_started = False
    
        async def sender(message: Message) -> None:
            nonlocal response_started
    
            if message["type"] == "http.response.start":
                response_started = True
            await send(message)
    
        try:
>           await app(scope, receive, sender)

/opt/homebrew/Caskroom/miniconda/base/lib/python3.11/site-packages/starlette/_exception_handler.py:53: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <fastapi.routing.APIRouter object at 0x119bf7ad0>
scope = {'app': <fastapi.applications.FastAPI object at 0x119bf5710>, 'asgi': {'version': '3.0'}, 'client': ('127.0.0.1', 123), 'endpoint': <function create_orders_batch at 0x1191c7380>, ...}
receive = <function ASGITransport.handle_async_request.<locals>.receive at 0x119cc54e0>
send = <function wrap_app_handling_exceptions.<locals>.wrapped_app.<locals>.sender at 0x119f9ea20>

    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:
        """
        The main entry point to the Router class.
        """
>       await self.middleware_stack(scope, receive, send)

/opt/homebrew/Caskroom/miniconda/base/lib/python3.11/site-packages/starlette/routing.py:756: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <fastapi.routing.APIRouter object at 0x119bf7ad0>
scope = {'app': <fastapi.applications.FastAPI object at 0x119bf5710>, 'asgi': {'version': '3.0'}, 'client': ('127.0.0.1', 123), 'endpoint': <function create_orders_batch at 0x1191c7380>, ...}
receive = <function ASGITransport.handle_async_request.<locals>.receive at 0x119cc54e0>
send = <function wrap_app_handling_exceptions.<locals>.wrapped_app.<locals>.sender at 0x119f9ea20>

    async def app(self, scope: Scope, receive: Receive, send: Send) -> None:
        assert scope["type"] in ("http", "websocket", "lifespan")
    
        if "router" not in scope:
            scope["router"] = self
    
        if scope["type"] == "lifespan":
            await self.lifespan(scope, receive, send)
            return
    
        partial = None
    
        for route in self.routes:
            # Determine if any route matches the incoming scope,
            # and hand over to the matching route if found.
            match, child_scope = route.matches(scope)
            if match == Match.FULL:
                scope.update(child_scope)
>               await route.handle(scope, receive, send)

/opt/homebrew/Caskroom/miniconda/base/lib/python3.11/site-packages/starlette/routing.py:776: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = APIRoute(path='/api/v1/contractors/orders', name='create_orders_batch', methods=['POST'])
scope = {'app': <fastapi.applications.FastAPI object at 0x119bf5710>, 'asgi': {'version': '3.0'}, 'client': ('127.0.0.1', 123), 'endpoint': <function create_orders_batch at 0x1191c7380>, ...}
receive = <function ASGITransport.handle_async_request.<locals>.receive at 0x119cc54e0>
send = <function wrap_app_handling_exceptions.<locals>.wrapped_app.<locals>.sender at 0x119f9ea20>

    async def handle(self, scope: Scope, receive: Receive, send: Send) -> None:
        if self.methods and scope["method"] not in self.methods:
            headers = {"Allow": ", ".join(self.methods)}
            if "app" in scope:
                raise HTTPException(status_code=405, headers=headers)
            else:
                response = PlainTextResponse(
                    "Method Not Allowed", status_code=405, headers=headers
                )
            await response(scope, receive, send)
        else:
>           await self.app(scope, receive, send)

/opt/homebrew/Caskroom/miniconda/base/lib/python3.11/site-packages/starlette/routing.py:297: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

scope = {'app': <fastapi.applications.FastAPI object at 0x119bf5710>, 'asgi': {'version': '3.0'}, 'client': ('127.0.0.1', 123), 'endpoint': <function create_orders_batch at 0x1191c7380>, ...}
receive = <function ASGITransport.handle_async_request.<locals>.receive at 0x119cc54e0>
send = <function wrap_app_handling_exceptions.<locals>.wrapped_app.<locals>.sender at 0x119f9ea20>

    async def app(scope: Scope, receive: Receive, send: Send) -> None:
        request = Request(scope, receive, send)
    
        async def app(scope: Scope, receive: Receive, send: Send) -> None:
            if is_async_callable(func):
                response = await func(request)
            else:
                response = await run_in_threadpool(func, request)
            await response(scope, receive, send)
    
>       await wrap_app_handling_exceptions(app, request)(scope, receive, send)

/opt/homebrew/Caskroom/miniconda/base/lib/python3.11/site-packages/starlette/routing.py:77: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

scope = {'app': <fastapi.applications.FastAPI object at 0x119bf5710>, 'asgi': {'version': '3.0'}, 'client': ('127.0.0.1', 123), 'endpoint': <function create_orders_batch at 0x1191c7380>, ...}
receive = <function ASGITransport.handle_async_request.<locals>.receive at 0x119cc54e0>
send = <function wrap_app_handling_exceptions.<locals>.wrapped_app.<locals>.sender at 0x119f9ea20>

    async def wrapped_app(scope: Scope, receive: Receive, send: Send) -> None:
        response_started = False
    
        async def sender(message: Message) -> None:
            nonlocal response_started
    
            if message["type"] == "http.response.start":
                response_started = True
            await send(message)
    
        try:
            await app(scope, receive, sender)
        except Exception as exc:
            handler = None
    
            if isinstance(exc, HTTPException):
                handler = status_handlers.get(exc.status_code)
    
            if handler is None:
                handler = _lookup_exception_handler(exception_handlers, exc)
    
            if handler is None:
>               raise exc

/opt/homebrew/Caskroom/miniconda/base/lib/python3.11/site-packages/starlette/_exception_handler.py:64: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

scope = {'app': <fastapi.applications.FastAPI object at 0x119bf5710>, 'asgi': {'version': '3.0'}, 'client': ('127.0.0.1', 123), 'endpoint': <function create_orders_batch at 0x1191c7380>, ...}
receive = <function ASGITransport.handle_async_request.<locals>.receive at 0x119cc54e0>
send = <function wrap_app_handling_exceptions.<locals>.wrapped_app.<locals>.sender at 0x119f9ea20>

    async def wrapped_app(scope: Scope, receive: Receive, send: Send) -> None:
        response_started = False
    
        async def sender(message: Message) -> None:
            nonlocal response_started
    
            if message["type"] == "http.response.start":
                response_started = True
            await send(message)
    
        try:
>           await app(scope, receive, sender)

/opt/homebrew/Caskroom/miniconda/base/lib/python3.11/site-packages/starlette/_exception_handler.py:53: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

scope = {'app': <fastapi.applications.FastAPI object at 0x119bf5710>, 'asgi': {'version': '3.0'}, 'client': ('127.0.0.1', 123), 'endpoint': <function create_orders_batch at 0x1191c7380>, ...}
receive = <function ASGITransport.handle_async_request.<locals>.receive at 0x119cc54e0>
send = <function wrap_app_handling_exceptions.<locals>.wrapped_app.<locals>.sender at 0x119fb3d80>

    async def app(scope: Scope, receive: Receive, send: Send) -> None:
        if is_async_callable(func):
>           response = await func(request)
                       ^^^^^^^^^^^^^^^^^^^

/opt/homebrew/Caskroom/miniconda/base/lib/python3.11/site-packages/starlette/routing.py:72: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <starlette.requests.Request object at 0x119fd6a90>

    async def app(request: Request) -> Response:
        response: Union[Response, None] = None
        async with AsyncExitStack() as file_stack:
            try:
                body: Any = None
                if body_field:
                    if is_body_form:
                        body = await request.form()
                        file_stack.push_async_callback(body.close)
                    else:
                        body_bytes = await request.body()
                        if body_bytes:
                            json_body: Any = Undefined
                            content_type_value = request.headers.get("content-type")
                            if not content_type_value:
                                json_body = await request.json()
                            else:
                                message = email.message.Message()
                                message["content-type"] = content_type_value
                                if message.get_content_maintype() == "application":
                                    subtype = message.get_content_subtype()
                                    if subtype == "json" or subtype.endswith("+json"):
                                        json_body = await request.json()
                            if json_body != Undefined:
                                body = json_body
                            else:
                                body = body_bytes
            except json.JSONDecodeError as e:
                validation_error = RequestValidationError(
                    [
                        {
                            "type": "json_invalid",
                            "loc": ("body", e.pos),
                            "msg": "JSON decode error",
                            "input": {},
                            "ctx": {"error": e.msg},
                        }
                    ],
                    body=e.doc,
                )
                raise validation_error from e
            except HTTPException:
                # If a middleware raises an HTTPException, it should be raised again
                raise
            except Exception as e:
                http_error = HTTPException(
                    status_code=400, detail="There was an error parsing the body"
                )
                raise http_error from e
            errors: List[Any] = []
            async with AsyncExitStack() as async_exit_stack:
>               solved_result = await solve_dependencies(
                    request=request,
                    dependant=dependant,
                    body=body,
                    dependency_overrides_provider=dependency_overrides_provider,
                    async_exit_stack=async_exit_stack,
                )

/opt/homebrew/Caskroom/miniconda/base/lib/python3.11/site-packages/fastapi/routing.py:269: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    async def solve_dependencies(
        *,
        request: Union[Request, WebSocket],
        dependant: Dependant,
        body: Optional[Union[Dict[str, Any], FormData]] = None,
        background_tasks: Optional[StarletteBackgroundTasks] = None,
        response: Optional[Response] = None,
        dependency_overrides_provider: Optional[Any] = None,
        dependency_cache: Optional[Dict[Tuple[Callable[..., Any], Tuple[str]], Any]] = None,
        async_exit_stack: AsyncExitStack,
    ) -> Tuple[
        Dict[str, Any],
        List[Any],
        Optional[StarletteBackgroundTasks],
        Response,
        Dict[Tuple[Callable[..., Any], Tuple[str]], Any],
    ]:
        values: Dict[str, Any] = {}
        errors: List[Any] = []
        if response is None:
            response = Response()
            del response.headers["content-length"]
            response.status_code = None  # type: ignore
        dependency_cache = dependency_cache or {}
        sub_dependant: Dependant
        for sub_dependant in dependant.dependencies:
            sub_dependant.call = cast(Callable[..., Any], sub_dependant.call)
            sub_dependant.cache_key = cast(
                Tuple[Callable[..., Any], Tuple[str]], sub_dependant.cache_key
            )
            call = sub_dependant.call
            use_sub_dependant = sub_dependant
            if (
                dependency_overrides_provider
                and dependency_overrides_provider.dependency_overrides
            ):
                original_call = sub_dependant.call
                call = getattr(
                    dependency_overrides_provider, "dependency_overrides", {}
                ).get(original_call, original_call)
                use_path: str = sub_dependant.path  # type: ignore
                use_sub_dependant = get_dependant(
                    path=use_path,
                    call=call,
                    name=sub_dependant.name,
                    security_scopes=sub_dependant.security_scopes,
                )
    
            solved_result = await solve_dependencies(
                request=request,
                dependant=use_sub_dependant,
                body=body,
                background_tasks=background_tasks,
                response=response,
                dependency_overrides_provider=dependency_overrides_provider,
                dependency_cache=dependency_cache,
                async_exit_stack=async_exit_stack,
            )
            (
                sub_values,
                sub_errors,
                background_tasks,
                _,  # the subdependency returns the same response we have
                sub_dependency_cache,
            ) = solved_result
            dependency_cache.update(sub_dependency_cache)
            if sub_errors:
                errors.extend(sub_errors)
                continue
            if sub_dependant.use_cache and sub_dependant.cache_key in dependency_cache:
                solved = dependency_cache[sub_dependant.cache_key]
            elif is_gen_callable(call) or is_async_gen_callable(call):
                solved = await solve_generator(
                    call=call, stack=async_exit_stack, sub_values=sub_values
                )
            elif is_coroutine_callable(call):
>               solved = await call(**sub_values)
                         ^^^^^^^^^^^^^^^^^^^^^^^^

/opt/homebrew/Caskroom/miniconda/base/lib/python3.11/site-packages/fastapi/dependencies/utils.py:600: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

api_key = 'test-api-key-123'
session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x119fa83d0>

    async def get_contractor(
        api_key: str = Security(api_key_header),
        session: AsyncSession = Depends(get_db)
    ) -> Contractor:
        """Проверка API ключа подрядчика."""
        query = select(Contractor).where(Contractor.api_key == api_key, Contractor.is_active == True)
>       result = await session.execute(query)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^

src/api/contractors.py:29: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x119fa83d0>
statement = <sqlalchemy.sql.selectable.Select object at 0x119fe4210>
params = None, execution_options = immutabledict({'prebuffer_rows': True})
bind_arguments = None, kw = {}

    async def execute(
        self,
        statement: Executable,
        params: Optional[_CoreAnyExecuteParams] = None,
        *,
        execution_options: OrmExecuteOptionsParameter = util.EMPTY_DICT,
        bind_arguments: Optional[_BindArguments] = None,
        **kw: Any,
    ) -> Result[Any]:
        """Execute a statement and return a buffered
        :class:`_engine.Result` object.
    
        .. seealso::
    
            :meth:`_orm.Session.execute` - main documentation for execute
    
        """
    
        if execution_options:
            execution_options = util.immutabledict(execution_options).union(
                _EXECUTE_OPTIONS
            )
        else:
            execution_options = _EXECUTE_OPTIONS
    
>       result = await greenlet_spawn(
            self.sync_session.execute,
            statement,
            params=params,
            execution_options=execution_options,
            bind_arguments=bind_arguments,
            **kw,
        )

/opt/homebrew/Caskroom/miniconda/base/lib/python3.11/site-packages/sqlalchemy/ext/asyncio/session.py:449: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <bound method Session.execute of <sqlalchemy.orm.session.Session object at 0x119fd7f10>>
_require_await = False
args = (<sqlalchemy.sql.selectable.Select object at 0x119fe4210>,)
kwargs = {'bind_arguments': None, 'execution_options': immutabledict({'prebuffer_rows': True}), 'params': None}
context = <_AsyncIoGreenlet object at 0x119fe4280 (otid=0x1069dacd0) dead>
switch_occurred = True
result = <coroutine object AsyncAdapt_asyncpg_cursor._prepare_and_execute at 0x119f12440>
value = None

    async def greenlet_spawn(
        fn: Callable[..., _T],
        *args: Any,
        _require_await: bool = False,
        **kwargs: Any,
    ) -> _T:
        """Runs a sync function ``fn`` in a new greenlet.
    
        The sync function can then use :func:`await_only` to wait for async
        functions.
    
        :param fn: The sync callable to call.
        :param \\*args: Positional arguments to pass to the ``fn`` callable.
        :param \\*\\*kwargs: Keyword arguments to pass to the ``fn`` callable.
        """
    
        result: Any
        context = _AsyncIoGreenlet(fn, getcurrent())
        # runs the function synchronously in gl greenlet. If the execution
        # is interrupted by await_only, context is not dead and result is a
        # coroutine to wait. If the context is dead the function has
        # returned, and its result can be returned.
        switch_occurred = False
        result = context.switch(*args, **kwargs)
        while not context.dead:
            switch_occurred = True
            try:
                # wait for a coroutine from await_only and then return its
                # result back to it.
                value = await result
            except BaseException:
                # this allows an exception to be raised within
                # the moderated greenlet so that it can continue
                # its expected flow.
>               result = context.throw(*sys.exc_info())
                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/opt/homebrew/Caskroom/miniconda/base/lib/python3.11/site-packages/sqlalchemy/util/_concurrency_py3k.py:201: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.Session object at 0x119fd7f10>
statement = <sqlalchemy.sql.selectable.Select object at 0x119fe4210>
params = None

    def execute(
        self,
        statement: Executable,
        params: Optional[_CoreAnyExecuteParams] = None,
        *,
        execution_options: OrmExecuteOptionsParameter = util.EMPTY_DICT,
        bind_arguments: Optional[_BindArguments] = None,
        _parent_execute_state: Optional[Any] = None,
        _add_event: Optional[Any] = None,
    ) -> Result[Any]:
        r"""Execute a SQL expression construct.
    
        Returns a :class:`_engine.Result` object representing
        results of the statement execution.
    
        E.g.::
    
            from sqlalchemy import select
    
            result = session.execute(select(User).where(User.id == 5))
    
        The API contract of :meth:`_orm.Session.execute` is similar to that
        of :meth:`_engine.Connection.execute`, the :term:`2.0 style` version
        of :class:`_engine.Connection`.
    
        .. versionchanged:: 1.4 the :meth:`_orm.Session.execute` method is
           now the primary point of ORM statement execution when using
           :term:`2.0 style` ORM usage.
    
        :param statement:
            An executable statement (i.e. an :class:`.Executable` expression
            such as :func:`_expression.select`).
    
        :param params:
            Optional dictionary, or list of dictionaries, containing
            bound parameter values.   If a single dictionary, single-row
            execution occurs; if a list of dictionaries, an
            "executemany" will be invoked.  The keys in each dictionary
            must correspond to parameter names present in the statement.
    
        :param execution_options: optional dictionary of execution options,
         which will be associated with the statement execution.  This
         dictionary can provide a subset of the options that are accepted
         by :meth:`_engine.Connection.execution_options`, and may also
         provide additional options understood only in an ORM context.
    
         .. seealso::
    
            :ref:`orm_queryguide_execution_options` - ORM-specific execution
            options
    
        :param bind_arguments: dictionary of additional arguments to determine
         the bind.  May include "mapper", "bind", or other custom arguments.
         Contents of this dictionary are passed to the
         :meth:`.Session.get_bind` method.
    
        :return: a :class:`_engine.Result` object.
    
    
        """
>       return self._execute_internal(
            statement,
            params,
            execution_options=execution_options,
            bind_arguments=bind_arguments,
            _parent_execute_state=_parent_execute_state,
            _add_event=_add_event,
        )

/opt/homebrew/Caskroom/miniconda/base/lib/python3.11/site-packages/sqlalchemy/orm/session.py:2351: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.Session object at 0x119fd7f10>
statement = <sqlalchemy.sql.selectable.Select object at 0x119fe4210>
params = None

    def _execute_internal(
        self,
        statement: Executable,
        params: Optional[_CoreAnyExecuteParams] = None,
        *,
        execution_options: OrmExecuteOptionsParameter = util.EMPTY_DICT,
        bind_arguments: Optional[_BindArguments] = None,
        _parent_execute_state: Optional[Any] = None,
        _add_event: Optional[Any] = None,
        _scalar_result: bool = False,
    ) -> Any:
        statement = coercions.expect(roles.StatementRole, statement)
    
        if not bind_arguments:
            bind_arguments = {}
        else:
            bind_arguments = dict(bind_arguments)
    
        if (
            statement._propagate_attrs.get("compile_state_plugin", None)
            == "orm"
        ):
            compile_state_cls = CompileState._get_plugin_class_for_plugin(
                statement, "orm"
            )
            if TYPE_CHECKING:
                assert isinstance(
                    compile_state_cls, context.AbstractORMCompileState
                )
        else:
            compile_state_cls = None
            bind_arguments.setdefault("clause", statement)
    
        execution_options = util.coerce_to_immutabledict(execution_options)
    
        if _parent_execute_state:
            events_todo = _parent_execute_state._remaining_events()
        else:
            events_todo = self.dispatch.do_orm_execute
            if _add_event:
                events_todo = list(events_todo) + [_add_event]
    
        if events_todo:
            if compile_state_cls is not None:
                # for event handlers, do the orm_pre_session_exec
                # pass ahead of the event handlers, so that things like
                # .load_options, .update_delete_options etc. are populated.
                # is_pre_event=True allows the hook to hold off on things
                # it doesn't want to do twice, including autoflush as well
                # as "pre fetch" for DML, etc.
                (
                    statement,
                    execution_options,
                ) = compile_state_cls.orm_pre_session_exec(
                    self,
                    statement,
                    params,
                    execution_options,
                    bind_arguments,
                    True,
                )
    
            orm_exec_state = ORMExecuteState(
                self,
                statement,
                params,
                execution_options,
                bind_arguments,
                compile_state_cls,
                events_todo,
            )
            for idx, fn in enumerate(events_todo):
                orm_exec_state._starting_event_idx = idx
                fn_result: Optional[Result[Any]] = fn(orm_exec_state)
                if fn_result:
                    if _scalar_result:
                        return fn_result.scalar()
                    else:
                        return fn_result
    
            statement = orm_exec_state.statement
            execution_options = orm_exec_state.local_execution_options
    
        if compile_state_cls is not None:
            # now run orm_pre_session_exec() "for real".   if there were
            # event hooks, this will re-run the steps that interpret
            # new execution_options into load_options / update_delete_options,
            # which we assume the event hook might have updated.
            # autoflush will also be invoked in this step if enabled.
            (
                statement,
                execution_options,
            ) = compile_state_cls.orm_pre_session_exec(
                self,
                statement,
                params,
                execution_options,
                bind_arguments,
                False,
            )
    
        bind = self.get_bind(**bind_arguments)
    
        conn = self._connection_for_bind(bind)
    
        if _scalar_result and not compile_state_cls:
            if TYPE_CHECKING:
                params = cast(_CoreSingleExecuteParams, params)
            return conn.scalar(
                statement, params or {}, execution_options=execution_options
            )
    
        if compile_state_cls:
>           result: Result[Any] = compile_state_cls.orm_execute_statement(
                self,
                statement,
                params or {},
                execution_options,
                bind_arguments,
                conn,
            )

/opt/homebrew/Caskroom/miniconda/base/lib/python3.11/site-packages/sqlalchemy/orm/session.py:2249: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'sqlalchemy.orm.context.ORMSelectCompileState'>
session = <sqlalchemy.orm.session.Session object at 0x119fd7f10>
statement = <sqlalchemy.sql.selectable.Select object at 0x119fe4210>
params = {}
execution_options = immutabledict({'prebuffer_rows': True, '_result_disable_adapt_to_context': True})
bind_arguments = {'clause': <sqlalchemy.sql.selectable.Select object at 0x119fe4210>, 'mapper': <Mapper at 0x108a0ad50; Contractor>}
conn = <sqlalchemy.engine.base.Connection object at 0x119fe44d0>

    @classmethod
    def orm_execute_statement(
        cls,
        session,
        statement,
        params,
        execution_options,
        bind_arguments,
        conn,
    ) -> Result:
>       result = conn.execute(
            statement, params or {}, execution_options=execution_options
        )

/opt/homebrew/Caskroom/miniconda/base/lib/python3.11/site-packages/sqlalchemy/orm/context.py:306: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x119fe44d0>
statement = <sqlalchemy.sql.selectable.Select object at 0x119fe4210>
parameters = {}

    def execute(
        self,
        statement: Executable,
        parameters: Optional[_CoreAnyExecuteParams] = None,
        *,
        execution_options: Optional[CoreExecuteOptionsParameter] = None,
    ) -> CursorResult[Any]:
        r"""Executes a SQL statement construct and returns a
        :class:`_engine.CursorResult`.
    
        :param statement: The statement to be executed.  This is always
         an object that is in both the :class:`_expression.ClauseElement` and
         :class:`_expression.Executable` hierarchies, including:
    
         * :class:`_expression.Select`
         * :class:`_expression.Insert`, :class:`_expression.Update`,
           :class:`_expression.Delete`
         * :class:`_expression.TextClause` and
           :class:`_expression.TextualSelect`
         * :class:`_schema.DDL` and objects which inherit from
           :class:`_schema.ExecutableDDLElement`
    
        :param parameters: parameters which will be bound into the statement.
         This may be either a dictionary of parameter names to values,
         or a mutable sequence (e.g. a list) of dictionaries.  When a
         list of dictionaries is passed, the underlying statement execution
         will make use of the DBAPI ``cursor.executemany()`` method.
         When a single dictionary is passed, the DBAPI ``cursor.execute()``
         method will be used.
    
        :param execution_options: optional dictionary of execution options,
         which will be associated with the statement execution.  This
         dictionary can provide a subset of the options that are accepted
         by :meth:`_engine.Connection.execution_options`.
    
        :return: a :class:`_engine.Result` object.
    
        """
        distilled_parameters = _distill_params_20(parameters)
        try:
            meth = statement._execute_on_connection
        except AttributeError as err:
            raise exc.ObjectNotExecutableError(statement) from err
        else:
>           return meth(
                self,
                distilled_parameters,
                execution_options or NO_OPTIONS,
            )

/opt/homebrew/Caskroom/miniconda/base/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1419: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.sql.selectable.Select object at 0x119fe4210>
connection = <sqlalchemy.engine.base.Connection object at 0x119fe44d0>
distilled_params = [{}]
execution_options = immutabledict({'prebuffer_rows': True, '_result_disable_adapt_to_context': True})

    def _execute_on_connection(
        self,
        connection: Connection,
        distilled_params: _CoreMultiExecuteParams,
        execution_options: CoreExecuteOptionsParameter,
    ) -> Result[Any]:
        if self.supports_execution:
            if TYPE_CHECKING:
                assert isinstance(self, Executable)
>           return connection._execute_clauseelement(
                self, distilled_params, execution_options
            )

/opt/homebrew/Caskroom/miniconda/base/lib/python3.11/site-packages/sqlalchemy/sql/elements.py:527: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x119fe44d0>
elem = <sqlalchemy.sql.selectable.Select object at 0x119fe4210>
distilled_parameters = [{}]
execution_options = immutabledict({'prebuffer_rows': True, '_result_disable_adapt_to_context': True})

    def _execute_clauseelement(
        self,
        elem: Executable,
        distilled_parameters: _CoreMultiExecuteParams,
        execution_options: CoreExecuteOptionsParameter,
    ) -> CursorResult[Any]:
        """Execute a sql.ClauseElement object."""
    
        execution_options = elem._execution_options.merge_with(
            self._execution_options, execution_options
        )
    
        has_events = self._has_events or self.engine._has_events
        if has_events:
            (
                elem,
                distilled_parameters,
                event_multiparams,
                event_params,
            ) = self._invoke_before_exec_event(
                elem, distilled_parameters, execution_options
            )
    
        if distilled_parameters:
            # ensure we don't retain a link to the view object for keys()
            # which links to the values, which we don't want to cache
            keys = sorted(distilled_parameters[0])
            for_executemany = len(distilled_parameters) > 1
        else:
            keys = []
            for_executemany = False
    
        dialect = self.dialect
    
        schema_translate_map = execution_options.get(
            "schema_translate_map", None
        )
    
        compiled_cache: Optional[CompiledCacheType] = execution_options.get(
            "compiled_cache", self.engine._compiled_cache
        )
    
        compiled_sql, extracted_params, cache_hit = elem._compile_w_cache(
            dialect=dialect,
            compiled_cache=compiled_cache,
            column_keys=keys,
            for_executemany=for_executemany,
            schema_translate_map=schema_translate_map,
            linting=self.dialect.compiler_linting | compiler.WARN_LINTING,
        )
>       ret = self._execute_context(
            dialect,
            dialect.execution_ctx_cls._init_compiled,
            compiled_sql,
            distilled_parameters,
            execution_options,
            compiled_sql,
            distilled_parameters,
            elem,
            extracted_params,
            cache_hit=cache_hit,
        )

/opt/homebrew/Caskroom/miniconda/base/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1641: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x119fe44d0>
dialect = <sqlalchemy.dialects.postgresql.asyncpg.PGDialect_asyncpg object at 0x10897ef10>
constructor = <bound method DefaultExecutionContext._init_compiled of <class 'sqlalchemy.dialects.postgresql.asyncpg.PGExecutionContext_asyncpg'>>
statement = <sqlalchemy.dialects.postgresql.asyncpg.PGCompiler_asyncpg object at 0x119fe6890>
parameters = [{}]
execution_options = immutabledict({'prebuffer_rows': True, '_result_disable_adapt_to_context': True})
args = (<sqlalchemy.dialects.postgresql.asyncpg.PGCompiler_asyncpg object at 0x119fe6890>, [{}], <sqlalchemy.sql.selectable.Select object at 0x119fe4210>, [BindParameter('%(4731060624 api_key)s', 'test-api-key-123', type_=String(length=255))])
kw = {'cache_hit': <CacheStats.CACHE_MISS: 1>}, yp = None
conn = <sqlalchemy.pool.base._ConnectionFairy object at 0x119d07770>
context = <sqlalchemy.dialects.postgresql.asyncpg.PGExecutionContext_asyncpg object at 0x119fe6810>

    def _execute_context(
        self,
        dialect: Dialect,
        constructor: Callable[..., ExecutionContext],
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
        execution_options: _ExecuteOptions,
        *args: Any,
        **kw: Any,
    ) -> CursorResult[Any]:
        """Create an :class:`.ExecutionContext` and execute, returning
        a :class:`_engine.CursorResult`."""
    
        if execution_options:
            yp = execution_options.get("yield_per", None)
            if yp:
                execution_options = execution_options.union(
                    {"stream_results": True, "max_row_buffer": yp}
                )
        try:
            conn = self._dbapi_connection
            if conn is None:
                conn = self._revalidate_connection()
    
            context = constructor(
                dialect, self, conn, execution_options, *args, **kw
            )
        except (exc.PendingRollbackError, exc.ResourceClosedError):
            raise
        except BaseException as e:
            self._handle_dbapi_exception(
                e, str(statement), parameters, None, None
            )
    
        if (
            self._transaction
            and not self._transaction.is_active
            or (
                self._nested_transaction
                and not self._nested_transaction.is_active
            )
        ):
            self._invalid_transaction()
    
        elif self._trans_context_manager:
            TransactionalContext._trans_ctx_check(self)
    
        if self._transaction is None:
            self._autobegin()
    
        context.pre_exec()
    
        if context.execute_style is ExecuteStyle.INSERTMANYVALUES:
            return self._exec_insertmany_context(dialect, context)
        else:
>           return self._exec_single_context(
                dialect, context, statement, parameters
            )

/opt/homebrew/Caskroom/miniconda/base/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1846: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x119fe44d0>
dialect = <sqlalchemy.dialects.postgresql.asyncpg.PGDialect_asyncpg object at 0x10897ef10>
context = <sqlalchemy.dialects.postgresql.asyncpg.PGExecutionContext_asyncpg object at 0x119fe6810>
statement = <sqlalchemy.dialects.postgresql.asyncpg.PGCompiler_asyncpg object at 0x119fe6890>
parameters = [('test-api-key-123',)]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )
    
            if self._has_events or self.engine._has_events:
                self.dispatch.after_cursor_execute(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
            context.post_exec()
    
            result = context._setup_result_proxy()
    
        except BaseException as e:
>           self._handle_dbapi_exception(
                e, str_statement, effective_parameters, cursor, context
            )

/opt/homebrew/Caskroom/miniconda/base/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1986: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x119fe44d0>
e = ProgrammingError('<class \'asyncpg.exceptions.UndefinedTableError\'>: relation "contractors" does not exist')
statement = 'SELECT contractors.id, contractors.name, contractors.api_key, contractors.webhook_url, contractors.is_active, contractors.created_at \nFROM contractors \nWHERE contractors.api_key = $1::VARCHAR AND contractors.is_active = true'
parameters = ('test-api-key-123',)
cursor = <sqlalchemy.dialects.postgresql.asyncpg.AsyncAdapt_asyncpg_cursor object at 0x119f820e0>
context = <sqlalchemy.dialects.postgresql.asyncpg.PGExecutionContext_asyncpg object at 0x119fe6810>
is_sub_exec = False

    def _handle_dbapi_exception(
        self,
        e: BaseException,
        statement: Optional[str],
        parameters: Optional[_AnyExecuteParams],
        cursor: Optional[DBAPICursor],
        context: Optional[ExecutionContext],
        is_sub_exec: bool = False,
    ) -> NoReturn:
        exc_info = sys.exc_info()
    
        is_exit_exception = util.is_exit_exception(e)
    
        if not self._is_disconnect:
            self._is_disconnect = (
                isinstance(e, self.dialect.loaded_dbapi.Error)
                and not self.closed
                and self.dialect.is_disconnect(
                    e,
                    self._dbapi_connection if not self.invalidated else None,
                    cursor,
                )
            ) or (is_exit_exception and not self.closed)
    
        invalidate_pool_on_disconnect = not is_exit_exception
    
        ismulti: bool = (
            not is_sub_exec and context.executemany
            if context is not None
            else False
        )
        if self._reentrant_error:
            raise exc.DBAPIError.instance(
                statement,
                parameters,
                e,
                self.dialect.loaded_dbapi.Error,
                hide_parameters=self.engine.hide_parameters,
                dialect=self.dialect,
                ismulti=ismulti,
            ).with_traceback(exc_info[2]) from e
        self._reentrant_error = True
        try:
            # non-DBAPI error - if we already got a context,
            # or there's no string statement, don't wrap it
            should_wrap = isinstance(e, self.dialect.loaded_dbapi.Error) or (
                statement is not None
                and context is None
                and not is_exit_exception
            )
    
            if should_wrap:
                sqlalchemy_exception = exc.DBAPIError.instance(
                    statement,
                    parameters,
                    cast(Exception, e),
                    self.dialect.loaded_dbapi.Error,
                    hide_parameters=self.engine.hide_parameters,
                    connection_invalidated=self._is_disconnect,
                    dialect=self.dialect,
                    ismulti=ismulti,
                )
            else:
                sqlalchemy_exception = None
    
            newraise = None
    
            if (self.dialect._has_events) and not self._execution_options.get(
                "skip_user_error_events", False
            ):
                ctx = ExceptionContextImpl(
                    e,
                    sqlalchemy_exception,
                    self.engine,
                    self.dialect,
                    self,
                    cursor,
                    statement,
                    parameters,
                    context,
                    self._is_disconnect,
                    invalidate_pool_on_disconnect,
                    False,
                )
    
                for fn in self.dialect.dispatch.handle_error:
                    try:
                        # handler returns an exception;
                        # call next handler in a chain
                        per_fn = fn(ctx)
                        if per_fn is not None:
                            ctx.chained_exception = newraise = per_fn
                    except Exception as _raised:
                        # handler raises an exception - stop processing
                        newraise = _raised
                        break
    
                if self._is_disconnect != ctx.is_disconnect:
                    self._is_disconnect = ctx.is_disconnect
                    if sqlalchemy_exception:
                        sqlalchemy_exception.connection_invalidated = (
                            ctx.is_disconnect
                        )
    
                # set up potentially user-defined value for
                # invalidate pool.
                invalidate_pool_on_disconnect = (
                    ctx.invalidate_pool_on_disconnect
                )
    
            if should_wrap and context:
                context.handle_dbapi_exception(e)
    
            if not self._is_disconnect:
                if cursor:
                    self._safe_close_cursor(cursor)
                # "autorollback" was mostly relevant in 1.x series.
                # It's very unlikely to reach here, as the connection
                # does autobegin so when we are here, we are usually
                # in an explicit / semi-explicit transaction.
                # however we have a test which manufactures this
                # scenario in any case using an event handler.
                # test/engine/test_execute.py-> test_actual_autorollback
                if not self.in_transaction():
                    self._rollback_impl()
    
            if newraise:
                raise newraise.with_traceback(exc_info[2]) from e
            elif should_wrap:
                assert sqlalchemy_exception is not None
>               raise sqlalchemy_exception.with_traceback(exc_info[2]) from e

/opt/homebrew/Caskroom/miniconda/base/lib/python3.11/site-packages/sqlalchemy/engine/base.py:2363: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x119fe44d0>
dialect = <sqlalchemy.dialects.postgresql.asyncpg.PGDialect_asyncpg object at 0x10897ef10>
context = <sqlalchemy.dialects.postgresql.asyncpg.PGExecutionContext_asyncpg object at 0x119fe6810>
statement = <sqlalchemy.dialects.postgresql.asyncpg.PGCompiler_asyncpg object at 0x119fe6890>
parameters = [('test-api-key-123',)]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

/opt/homebrew/Caskroom/miniconda/base/lib/python3.11/site-packages/sqlalchemy/engine/base.py:1967: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.asyncpg.PGDialect_asyncpg object at 0x10897ef10>
cursor = <sqlalchemy.dialects.postgresql.asyncpg.AsyncAdapt_asyncpg_cursor object at 0x119f820e0>
statement = 'SELECT contractors.id, contractors.name, contractors.api_key, contractors.webhook_url, contractors.is_active, contractors.created_at \nFROM contractors \nWHERE contractors.api_key = $1::VARCHAR AND contractors.is_active = true'
parameters = ('test-api-key-123',)
context = <sqlalchemy.dialects.postgresql.asyncpg.PGExecutionContext_asyncpg object at 0x119fe6810>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)

/opt/homebrew/Caskroom/miniconda/base/lib/python3.11/site-packages/sqlalchemy/engine/default.py:952: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.asyncpg.AsyncAdapt_asyncpg_cursor object at 0x119f820e0>
operation = 'SELECT contractors.id, contractors.name, contractors.api_key, contractors.webhook_url, contractors.is_active, contractors.created_at \nFROM contractors \nWHERE contractors.api_key = $1::VARCHAR AND contractors.is_active = true'
parameters = ('test-api-key-123',)

    def execute(self, operation, parameters=None):
>       self._adapt_connection.await_(
            self._prepare_and_execute(operation, parameters)
        )

/opt/homebrew/Caskroom/miniconda/base/lib/python3.11/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:585: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

awaitable = <coroutine object AsyncAdapt_asyncpg_cursor._prepare_and_execute at 0x119f12440>

    def await_only(awaitable: Awaitable[_T]) -> _T:
        """Awaits an async function in a sync method.
    
        The sync method must be inside a :func:`greenlet_spawn` context.
        :func:`await_only` calls cannot be nested.
    
        :param awaitable: The coroutine to call.
    
        """
        # this is called in the context greenlet while running fn
        current = getcurrent()
        if not getattr(current, "__sqlalchemy_greenlet_provider__", False):
            _safe_cancel_awaitable(awaitable)
    
            raise exc.MissingGreenlet(
                "greenlet_spawn has not been called; can't call await_only() "
                "here. Was IO attempted in an unexpected place?"
            )
    
        # returns the control to the driver greenlet passing it
        # a coroutine to run. Once the awaitable is done, the driver greenlet
        # switches back to this greenlet with the result of awaitable that is
        # then returned to the caller (or raised as error)
>       return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/opt/homebrew/Caskroom/miniconda/base/lib/python3.11/site-packages/sqlalchemy/util/_concurrency_py3k.py:132: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <bound method Session.execute of <sqlalchemy.orm.session.Session object at 0x119fd7f10>>
_require_await = False
args = (<sqlalchemy.sql.selectable.Select object at 0x119fe4210>,)
kwargs = {'bind_arguments': None, 'execution_options': immutabledict({'prebuffer_rows': True}), 'params': None}
context = <_AsyncIoGreenlet object at 0x119fe4280 (otid=0x1069dacd0) dead>
switch_occurred = True
result = <coroutine object AsyncAdapt_asyncpg_cursor._prepare_and_execute at 0x119f12440>
value = None

    async def greenlet_spawn(
        fn: Callable[..., _T],
        *args: Any,
        _require_await: bool = False,
        **kwargs: Any,
    ) -> _T:
        """Runs a sync function ``fn`` in a new greenlet.
    
        The sync function can then use :func:`await_only` to wait for async
        functions.
    
        :param fn: The sync callable to call.
        :param \\*args: Positional arguments to pass to the ``fn`` callable.
        :param \\*\\*kwargs: Keyword arguments to pass to the ``fn`` callable.
        """
    
        result: Any
        context = _AsyncIoGreenlet(fn, getcurrent())
        # runs the function synchronously in gl greenlet. If the execution
        # is interrupted by await_only, context is not dead and result is a
        # coroutine to wait. If the context is dead the function has
        # returned, and its result can be returned.
        switch_occurred = False
        result = context.switch(*args, **kwargs)
        while not context.dead:
            switch_occurred = True
            try:
                # wait for a coroutine from await_only and then return its
                # result back to it.
>               value = await result
                        ^^^^^^^^^^^^

/opt/homebrew/Caskroom/miniconda/base/lib/python3.11/site-packages/sqlalchemy/util/_concurrency_py3k.py:196: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.asyncpg.AsyncAdapt_asyncpg_cursor object at 0x119f820e0>
operation = 'SELECT contractors.id, contractors.name, contractors.api_key, contractors.webhook_url, contractors.is_active, contractors.created_at \nFROM contractors \nWHERE contractors.api_key = $1::VARCHAR AND contractors.is_active = true'
parameters = ('test-api-key-123',)

    async def _prepare_and_execute(self, operation, parameters):
        adapt_connection = self._adapt_connection
    
        async with adapt_connection._execute_mutex:
            if not adapt_connection._started:
                await adapt_connection._start_transaction()
    
            if parameters is None:
                parameters = ()
    
            try:
                prepared_stmt, attributes = await adapt_connection._prepare(
                    operation, self._invalidate_schema_cache_asof
                )
    
                if attributes:
                    self.description = [
                        (
                            attr.name,
                            attr.type.oid,
                            None,
                            None,
                            None,
                            None,
                            None,
                        )
                        for attr in attributes
                    ]
                else:
                    self.description = None
    
                if self.server_side:
                    self._cursor = await prepared_stmt.cursor(*parameters)
                    self.rowcount = -1
                else:
                    self._rows = deque(await prepared_stmt.fetch(*parameters))
                    status = prepared_stmt.get_statusmsg()
    
                    reg = re.match(
                        r"(?:SELECT|UPDATE|DELETE|INSERT \d+) (\d+)",
                        status or "",
                    )
                    if reg:
                        self.rowcount = int(reg.group(1))
                    else:
                        self.rowcount = -1
    
            except Exception as error:
>               self._handle_exception(error)

/opt/homebrew/Caskroom/miniconda/base/lib/python3.11/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:563: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.asyncpg.AsyncAdapt_asyncpg_cursor object at 0x119f820e0>
error = UndefinedTableError('relation "contractors" does not exist')

    def _handle_exception(self, error):
>       self._adapt_connection._handle_exception(error)

/opt/homebrew/Caskroom/miniconda/base/lib/python3.11/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:513: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <AdaptedConnection <asyncpg.connection.Connection object at 0x119fec8b0>>
error = UndefinedTableError('relation "contractors" does not exist')

    def _handle_exception(self, error):
        if self._connection.is_closed():
            self._transaction = None
            self._started = False
    
        if not isinstance(error, AsyncAdapt_asyncpg_dbapi.Error):
            exception_mapping = self.dbapi._asyncpg_error_translate
    
            for super_ in type(error).__mro__:
                if super_ in exception_mapping:
                    translated_error = exception_mapping[super_](
                        "%s: %s" % (type(error), error)
                    )
                    translated_error.pgcode = translated_error.sqlstate = (
                        getattr(error, "sqlstate", None)
                    )
>                   raise translated_error from error
E                   sqlalchemy.exc.ProgrammingError: (sqlalchemy.dialects.postgresql.asyncpg.ProgrammingError) <class 'asyncpg.exceptions.UndefinedTableError'>: relation "contractors" does not exist
E                   [SQL: SELECT contractors.id, contractors.name, contractors.api_key, contractors.webhook_url, contractors.is_active, contractors.created_at 
E                   FROM contractors 
E                   WHERE contractors.api_key = $1::VARCHAR AND contractors.is_active = true]
E                   [parameters: ('test-api-key-123',)]
E                   (Background on this error at: https://sqlalche.me/e/20/f405)

/opt/homebrew/Caskroom/miniconda/base/lib/python3.11/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:797: ProgrammingError
----------------------------- Captured stdout call -----------------------------
2026-01-12 07:05:12,509 INFO sqlalchemy.engine.Engine select pg_catalog.version()
select pg_catalog.version()
2026-01-12 07:05:12,510 INFO sqlalchemy.engine.Engine [raw sql] ()
[raw sql] ()
2026-01-12 07:05:12,511 INFO sqlalchemy.engine.Engine select current_schema()
select current_schema()
2026-01-12 07:05:12,511 INFO sqlalchemy.engine.Engine [raw sql] ()
[raw sql] ()
2026-01-12 07:05:12,512 INFO sqlalchemy.engine.Engine show standard_conforming_strings
show standard_conforming_strings
2026-01-12 07:05:12,512 INFO sqlalchemy.engine.Engine [raw sql] ()
[raw sql] ()
2026-01-12 07:05:12,512 INFO sqlalchemy.engine.Engine BEGIN (implicit)
BEGIN (implicit)
2026-01-12 07:05:12,513 INFO sqlalchemy.engine.Engine SELECT contractors.id, contractors.name, contractors.api_key, contractors.webhook_url, contractors.is_active, contractors.created_at 
FROM contractors 
WHERE contractors.api_key = $1::VARCHAR AND contractors.is_active = true
SELECT contractors.id, contractors.name, contractors.api_key, contractors.webhook_url, contractors.is_active, contractors.created_at 
FROM contractors 
WHERE contractors.api_key = $1::VARCHAR AND contractors.is_active = true
2026-01-12 07:05:12,513 INFO sqlalchemy.engine.Engine [generated in 0.00011s] ('test-api-key-123',)
[generated in 0.00011s] ('test-api-key-123',)
2026-01-12 07:05:12,514 INFO sqlalchemy.engine.Engine ROLLBACK
ROLLBACK
------------------------------ Captured log call -------------------------------
INFO     sqlalchemy.engine.Engine:base.py:1846 select pg_catalog.version()
INFO     sqlalchemy.engine.Engine:base.py:1846 [raw sql] ()
INFO     sqlalchemy.engine.Engine:base.py:1846 select current_schema()
INFO     sqlalchemy.engine.Engine:base.py:1846 [raw sql] ()
INFO     sqlalchemy.engine.Engine:base.py:1846 show standard_conforming_strings
INFO     sqlalchemy.engine.Engine:base.py:1846 [raw sql] ()
INFO     sqlalchemy.engine.Engine:base.py:2710 BEGIN (implicit)
INFO     sqlalchemy.engine.Engine:base.py:1846 SELECT contractors.id, contractors.name, contractors.api_key, contractors.webhook_url, contractors.is_active, contractors.created_at 
FROM contractors 
WHERE contractors.api_key = $1::VARCHAR AND contractors.is_active = true
INFO     sqlalchemy.engine.Engine:base.py:1846 [generated in 0.00011s] ('test-api-key-123',)
INFO     sqlalchemy.engine.Engine:base.py:2713 ROLLBACK
_________________________ test_urgent_assignment_logic _________________________

session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x119f327d0>
test_driver = <Driver(id=2, name='Test Driver', status=available)>

    @pytest.mark.asyncio
    async def test_urgent_assignment_logic(session: AsyncSession, test_driver):
        """Тест логики срочного назначения."""
        # 1. Мокаем LocationManager
        location_manager = MagicMock(spec=LocationManager)
    
        # Представим, что водитель находится совсем рядом (55.75, 37.62)
        # Координаты заказа тоже (55.75, 37.62)
>       location_manager.get_driver_location = AsyncMock(return_value=DriverLocation(
            driver_id=test_driver.id,
            latitude=55.7501,
            longitude=37.6201,
            status="available",
            recorded_at=datetime.utcnow()
        ))
E       pydantic_core._pydantic_core.ValidationError: 1 validation error for DriverLocation
E       timestamp
E         Field required [type=missing, input_value={'driver_id': 2, 'latitud..., 11, 21, 5, 13, 55415)}, input_type=dict]
E           For further information visit https://errors.pydantic.dev/2.12/v/missing

tests/test_modules_5_10.py:72: ValidationError
_______________________ test_contractor_invalid_api_key ________________________

client = <httpx.AsyncClient object at 0x11c7146d0>

    @pytest.mark.asyncio
    async def test_contractor_invalid_api_key(client: AsyncClient):
        """Тест неверного API ключа."""
        data = {"orders": []}
        headers = {"X-API-Key": "wrong-key"}
>       response = await client.post("/api/v1/contractors/orders", json=data, headers=headers)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_modules_5_10.py:108: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <httpx.AsyncClient object at 0x11c7146d0>
url = '/api/v1/contractors/orders'

    async def post(
        self,
        url: URL | str,
        *,
        content: RequestContent | None = None,
        data: RequestData | None = None,
        files: RequestFiles | None = None,
        json: typing.Any | None = None,
        params: QueryParamTypes | None = None,
        headers: HeaderTypes | None = None,
        cookies: CookieTypes | None = None,
        auth: AuthTypes | UseClientDefault = USE_CLIENT_DEFAULT,
        follow_redirects: bool | UseClientDefault = USE_CLIENT_DEFAULT,
        timeout: TimeoutTypes | UseClientDefault = USE_CLIENT_DEFAULT,
        extensions: RequestExtensions | None = None,
    ) -> Response:
        """
        Send a `POST` request.
    
        **Parameters**: See `httpx.request`.
        """
>       return await self.request(
            "POST",
            url,
            content=content,
            data=data,
            files=files,
            json=json,
            params=params,
            headers=headers,
            cookies=cookies,
            auth=auth,
            follow_redirects=follow_redirects,
            timeout=timeout,
            extensions=extensions,
        )

/opt/homebrew/Caskroom/miniconda/base/lib/python3.11/site-packages/httpx/_client.py:1859: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <httpx.AsyncClient object at 0x11c7146d0>, method = 'POST'
url = '/api/v1/contractors/orders'

    async def request(
        self,
        method: str,
        url: URL | str,
        *,
        content: RequestContent | None = None,
        data: RequestData | None = None,
        files: RequestFiles | None = None,
        json: typing.Any | None = None,
        params: QueryParamTypes | None = None,
        headers: HeaderTypes | None = None,
        cookies: CookieTypes | None = None,
        auth: AuthTypes | UseClientDefault | None = USE_CLIENT_DEFAULT,
        follow_redirects: bool | UseClientDefault = USE_CLIENT_DEFAULT,
        timeout: TimeoutTypes | UseClientDefault = USE_CLIENT_DEFAULT,
        extensions: RequestExtensions | None = None,
    ) -> Response:
        """
        Build and send a request.
    
        Equivalent to:
    
        ```python
        request = client.build_request(...)
        response = await client.send(request, ...)
        ```
    
        See `AsyncClient.build_request()`, `AsyncClient.send()`
        and [Merging of configuration][0] for how the various parameters
        are merged with client-level configuration.
    
        [0]: /advanced/clients/#merging-of-configuration
        """
    
        if cookies is not None:  # pragma: no cover
            message = (
                "Setting per-request cookies=<...> is being deprecated, because "
                "the expected behaviour on cookie persistence is ambiguous. Set "
                "cookies directly on the client instance instead."
            )
            warnings.warn(message, DeprecationWarning, stacklevel=2)
    
        request = self.build_request(
            method=method,
            url=url,
            content=content,
            data=data,
            files=files,
            json=json,
            params=params,
            headers=headers,
            cookies=cookies,
            timeout=timeout,
            extensions=extensions,
        )
>       return await self.send(request, auth=auth, follow_redirects=follow_redirects)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/opt/homebrew/Caskroom/miniconda/base/lib/python3.11/site-packages/httpx/_client.py:1540: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <httpx.AsyncClient object at 0x11c7146d0>
request = <Request('POST', 'http://test/api/v1/contractors/orders')>

    async def send(
        self,
        request: Request,
        *,
        stream: bool = False,
        auth: AuthTypes | UseClientDefault | None = USE_CLIENT_DEFAULT,
        follow_redirects: bool | UseClientDefault = USE_CLIENT_DEFAULT,
    ) -> Response:
        """
        Send a request.
    
        The request is sent as-is, unmodified.
    
        Typically you'll want to build one with `AsyncClient.build_request()`
        so that any client-level configuration is merged into the request,
        but passing an explicit `httpx.Request()` is supported as well.
    
        See also: [Request instances][0]
    
        [0]: /advanced/clients/#request-instances
        """
        if self._state == ClientState.CLOSED:
            raise RuntimeError("Cannot send a request, as the client has been closed.")
    
        self._state = ClientState.OPENED
        follow_redirects = (
            self.follow_redirects
            if isinstance(follow_redirects, UseClientDefault)
            else follow_redirects
        )
    
        self._set_timeout(request)
    
        auth = self._build_request_auth(request, auth)
    
>       response = await self._send_handling_auth(
            request,
            auth=auth,
            follow_redirects=follow_redirects,
            history=[],
        )

/opt/homebrew/Caskroom/miniconda/base/lib/python3.11/site-packages/httpx/_client.py:1629: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <httpx.AsyncClient object at 0x11c7146d0>
request = <Request('POST', 'http://test/api/v1/contractors/orders')>
auth = <httpx.Auth object at 0x11c717b50>, follow_redirects = False
history = []

    async def _send_handling_auth(
        self,
        request: Request,
        auth: Auth,
        follow_redirects: bool,
        history: list[Response],
    ) -> Response:
        auth_flow = auth.async_auth_flow(request)
        try:
            request = await auth_flow.__anext__()
    
            while True:
>               response = await self._send_handling_redirects(
                    request,
                    follow_redirects=follow_redirects,
                    history=history,
                )

/opt/homebrew/Caskroom/miniconda/base/lib/python3.11/site-packages/httpx/_client.py:1657: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <httpx.AsyncClient object at 0x11c7146d0>
request = <Request('POST', 'http://test/api/v1/contractors/orders')>
follow_redirects = False, history = []

    async def _send_handling_redirects(
        self,
        request: Request,
        follow_redirects: bool,
        history: list[Response],
    ) -> Response:
        while True:
            if len(history) > self.max_redirects:
                raise TooManyRedirects(
                    "Exceeded maximum allowed redirects.", request=request
                )
    
            for hook in self._event_hooks["request"]:
                await hook(request)
    
>           response = await self._send_single_request(request)
                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/opt/homebrew/Caskroom/miniconda/base/lib/python3.11/site-packages/httpx/_client.py:1694: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <httpx.AsyncClient object at 0x11c7146d0>
request = <Request('POST', 'http://test/api/v1/contractors/orders')>

    async def _send_single_request(self, request: Request) -> Response:
        """
        Sends a single request, without handling any redirections.
        """
        transport = self._transport_for_url(request.url)
        start = time.perf_counter()
    
        if not isinstance(request.stream, AsyncByteStream):
            raise RuntimeError(
                "Attempted to send an sync request with an AsyncClient instance."
            )
    
        with request_context(request=request):
>           response = await transport.handle_async_request(request)
                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/opt/homebrew/Caskroom/miniconda/base/lib/python3.11/site-packages/httpx/_client.py:1730: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <httpx.ASGITransport object at 0x11c714ad0>
request = <Request('POST', 'http://test/api/v1/contractors/orders')>

    async def handle_async_request(
        self,
        request: Request,
    ) -> Response:
        assert isinstance(request.stream, AsyncByteStream)
    
        # ASGI scope.
        scope = {
            "type": "http",
            "asgi": {"version": "3.0"},
            "http_version": "1.1",
            "method": request.method,
            "headers": [(k.lower(), v) for (k, v) in request.headers.raw],
            "scheme": request.url.scheme,
            "path": request.url.path,
            "raw_path": request.url.raw_path.split(b"?")[0],
            "query_string": request.url.query,
            "server": (request.url.host, request.url.port),
            "client": self.client,
            "root_path": self.root_path,
        }
    
        # Request.
        request_body_chunks = request.stream.__aiter__()
        request_complete = False
    
        # Response.
        status_code = None
        response_headers = None
        body_parts = []
        response_started = False
        response_complete = create_event()
    
        # ASGI callables.
    
        async def receive() -> dict[str, typing.Any]:
            nonlocal request_complete
    
            if request_complete:
                await response_complete.wait()
                return {"type": "http.disconnect"}
    
            try:
                body = await request_body_chunks.__anext__()
            except StopAsyncIteration:
                request_complete = True
                return {"type": "http.request", "body": b"", "more_body": False}
            return {"type": "http.request", "body": body, "more_body": True}
    
        async def send(message: typing.MutableMapping[str, typing.Any]) -> None:
            nonlocal status_code, response_headers, response_started
    
            if message["type"] == "http.response.start":
                assert not response_started
    
                status_code = message["status"]
                response_headers = message.get("headers", [])
                response_started = True
    
            elif message["type"] == "http.response.body":
                assert not response_complete.is_set()
                body = message.get("body", b"")
                more_body = message.get("more_body", False)
    
                if body and request.method != "HEAD":
                    body_parts.append(body)
    
                if not more_body:
                    response_complete.set()
    
        try:
>           await self.app(scope, receive, send)

/opt/homebrew/Caskroom/miniconda/base/lib/python3.11/site-packages/httpx/_transports/asgi.py:170: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <fastapi.applications.FastAPI object at 0x119bf5710>
scope = {'app': <fastapi.applications.FastAPI object at 0x119bf5710>, 'asgi': {'version': '3.0'}, 'client': ('127.0.0.1', 123), 'endpoint': <function create_orders_batch at 0x1191c7380>, ...}
receive = <function ASGITransport.handle_async_request.<locals>.receive at 0x119fb0f40>
send = <function ASGITransport.handle_async_request.<locals>.send at 0x119fb2c00>

    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:
        if self.root_path:
            scope["root_path"] = self.root_path
>       await super().__call__(scope, receive, send)

/opt/homebrew/Caskroom/miniconda/base/lib/python3.11/site-packages/fastapi/applications.py:1054: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <fastapi.applications.FastAPI object at 0x119bf5710>
scope = {'app': <fastapi.applications.FastAPI object at 0x119bf5710>, 'asgi': {'version': '3.0'}, 'client': ('127.0.0.1', 123), 'endpoint': <function create_orders_batch at 0x1191c7380>, ...}
receive = <function ASGITransport.handle_async_request.<locals>.receive at 0x119fb0f40>
send = <function ASGITransport.handle_async_request.<locals>.send at 0x119fb2c00>

    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:
        scope["app"] = self
        if self.middleware_stack is None:
            self.middleware_stack = self.build_middleware_stack()
>       await self.middleware_stack(scope, receive, send)

/opt/homebrew/Caskroom/miniconda/base/lib/python3.11/site-packages/starlette/applications.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <starlette.middleware.errors.ServerErrorMiddleware object at 0x119fd7110>
scope = {'app': <fastapi.applications.FastAPI object at 0x119bf5710>, 'asgi': {'version': '3.0'}, 'client': ('127.0.0.1', 123), 'endpoint': <function create_orders_batch at 0x1191c7380>, ...}
receive = <function ASGITransport.handle_async_request.<locals>.receive at 0x119fb0f40>
send = <function ASGITransport.handle_async_request.<locals>.send at 0x119fb2c00>

    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:
        if scope["type"] != "http":
            await self.app(scope, receive, send)
            return
    
        response_started = False
    
        async def _send(message: Message) -> None:
            nonlocal response_started, send
    
            if message["type"] == "http.response.start":
                response_started = True
            await send(message)
    
        try:
            await self.app(scope, receive, _send)
        except Exception as exc:
            request = Request(scope)
            if self.debug:
                # In debug mode, return traceback responses.
                response = self.debug_response(request, exc)
            elif self.handler is None:
                # Use our default 500 error handler.
                response = self.error_response(request, exc)
            else:
                # Use an installed 500 error handler.
                if is_async_callable(self.handler):
                    response = await self.handler(request, exc)
                else:
                    response = await run_in_threadpool(self.handler, request, exc)
    
            if not response_started:
                await response(scope, receive, send)
    
            # We always continue to raise the exception.
            # This allows servers to log the error, or allows test clients
            # to optionally raise the error within the test case.
>           raise exc

/opt/homebrew/Caskroom/miniconda/base/lib/python3.11/site-packages/starlette/middleware/errors.py:186: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <starlette.middleware.errors.ServerErrorMiddleware object at 0x119fd7110>
scope = {'app': <fastapi.applications.FastAPI object at 0x119bf5710>, 'asgi': {'version': '3.0'}, 'client': ('127.0.0.1', 123), 'endpoint': <function create_orders_batch at 0x1191c7380>, ...}
receive = <function ASGITransport.handle_async_request.<locals>.receive at 0x119fb0f40>
send = <function ASGITransport.handle_async_request.<locals>.send at 0x119fb2c00>

    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:
        if scope["type"] != "http":
            await self.app(scope, receive, send)
            return
    
        response_started = False
    
        async def _send(message: Message) -> None:
            nonlocal response_started, send
    
            if message["type"] == "http.response.start":
                response_started = True
            await send(message)
    
        try:
>           await self.app(scope, receive, _send)

/opt/homebrew/Caskroom/miniconda/base/lib/python3.11/site-packages/starlette/middleware/errors.py:164: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <src.core.middleware.CorrelationIdMiddleware object at 0x119fd6f10>
scope = {'app': <fastapi.applications.FastAPI object at 0x119bf5710>, 'asgi': {'version': '3.0'}, 'client': ('127.0.0.1', 123), 'endpoint': <function create_orders_batch at 0x1191c7380>, ...}
receive = <function ASGITransport.handle_async_request.<locals>.receive at 0x119fb0f40>
send = <function ServerErrorMiddleware.__call__.<locals>._send at 0x11c4558a0>

    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:
        if scope["type"] not in ("http", "websocket"):
            await self.app(scope, receive, send)
            return
    
        # Извлекаем Correlation ID из заголовков
        correlation_id = None
        for key, value in scope.get("headers", []):
            if key == self.header_key:
                correlation_id = value.decode("latin-1")
                break
    
        if not correlation_id:
            correlation_id = str(uuid4())
    
        # Привязываем ID к контексту structlog
        structlog.contextvars.bind_contextvars(correlation_id=correlation_id)
    
        if scope["type"] == "http":
            structlog.contextvars.bind_contextvars(
                method=scope["method"],
                path=scope["path"],
            )
    
        async def send_wrapper(message):
            if message["type"] == "http.response.start":
                # Добавляем ID в заголовки HTTP ответа
                headers = list(message.get("headers", []))
                headers.append((self.header_key, correlation_id.encode("latin-1")))
                message["headers"] = headers
            await send(message)
    
        try:
            if scope["type"] == "http":
>               await self.app(scope, receive, send_wrapper)

src/core/middleware.py:50: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <starlette.middleware.cors.CORSMiddleware object at 0x119fd6e90>
scope = {'app': <fastapi.applications.FastAPI object at 0x119bf5710>, 'asgi': {'version': '3.0'}, 'client': ('127.0.0.1', 123), 'endpoint': <function create_orders_batch at 0x1191c7380>, ...}
receive = <function ASGITransport.handle_async_request.<locals>.receive at 0x119fb0f40>
send = <function CorrelationIdMiddleware.__call__.<locals>.send_wrapper at 0x11c456480>

    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:
        if scope["type"] != "http":  # pragma: no cover
            await self.app(scope, receive, send)
            return
    
        method = scope["method"]
        headers = Headers(scope=scope)
        origin = headers.get("origin")
    
        if origin is None:
>           await self.app(scope, receive, send)

/opt/homebrew/Caskroom/miniconda/base/lib/python3.11/site-packages/starlette/middleware/cors.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <starlette.middleware.exceptions.ExceptionMiddleware object at 0x119fd6e50>
scope = {'app': <fastapi.applications.FastAPI object at 0x119bf5710>, 'asgi': {'version': '3.0'}, 'client': ('127.0.0.1', 123), 'endpoint': <function create_orders_batch at 0x1191c7380>, ...}
receive = <function ASGITransport.handle_async_request.<locals>.receive at 0x119fb0f40>
send = <function CorrelationIdMiddleware.__call__.<locals>.send_wrapper at 0x11c456480>

    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:
        if scope["type"] not in ("http", "websocket"):
            await self.app(scope, receive, send)
            return
    
        scope["starlette.exception_handlers"] = (
            self._exception_handlers,
            self._status_handlers,
        )
    
        conn: Request | WebSocket
        if scope["type"] == "http":
            conn = Request(scope, receive, send)
        else:
            conn = WebSocket(scope, receive, send)
    
>       await wrap_app_handling_exceptions(self.app, conn)(scope, receive, send)

/opt/homebrew/Caskroom/miniconda/base/lib/python3.11/site-packages/starlette/middleware/exceptions.py:65: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

scope = {'app': <fastapi.applications.FastAPI object at 0x119bf5710>, 'asgi': {'version': '3.0'}, 'client': ('127.0.0.1', 123), 'endpoint': <function create_orders_batch at 0x1191c7380>, ...}
receive = <function ASGITransport.handle_async_request.<locals>.receive at 0x119fb0f40>
send = <function CorrelationIdMiddleware.__call__.<locals>.send_wrapper at 0x11c456480>

    async def wrapped_app(scope: Scope, receive: Receive, send: Send) -> None:
        response_started = False
    
        async def sender(message: Message) -> None:
            nonlocal response_started
    
            if message["type"] == "http.response.start":
                response_started = True
            await send(message)
    
        try:
            await app(scope, receive, sender)
        except Exception as exc:
            handler = None
    
            if isinstance(exc, HTTPException):
                handler = status_handlers.get(exc.status_code)
    
            if handler is None:
                handler = _lookup_exception_handler(exception_handlers, exc)
    
            if handler is None:
>               raise exc

/opt/homebrew/Caskroom/miniconda/base/lib/python3.11/site-packages/starlette/_exception_handler.py:64: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

scope = {'app': <fastapi.applications.FastAPI object at 0x119bf5710>, 'asgi': {'version': '3.0'}, 'client': ('127.0.0.1', 123), 'endpoint': <function create_orders_batch at 0x1191c7380>, ...}
receive = <function ASGITransport.handle_async_request.<locals>.receive at 0x119fb0f40>
send = <function CorrelationIdMiddleware.__call__.<locals>.send_wrapper at 0x11c456480>

    async def wrapped_app(scope: Scope, receive: Receive, send: Send) -> None:
        response_started = False
    
        async def sender(message: Message) -> None:
            nonlocal response_started
    
            if message["type"] == "http.response.start":
                response_started = True
            await send(message)
    
        try:
>           await app(scope, receive, sender)

/opt/homebrew/Caskroom/miniconda/base/lib/python3.11/site-packages/starlette/_exception_handler.py:53: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <fastapi.routing.APIRouter object at 0x119bf7ad0>
scope = {'app': <fastapi.applications.FastAPI object at 0x119bf5710>, 'asgi': {'version': '3.0'}, 'client': ('127.0.0.1', 123), 'endpoint': <function create_orders_batch at 0x1191c7380>, ...}
receive = <function ASGITransport.handle_async_request.<locals>.receive at 0x119fb0f40>
send = <function wrap_app_handling_exceptions.<locals>.wrapped_app.<locals>.sender at 0x11c454540>

    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:
        """
        The main entry point to the Router class.
        """
>       await self.middleware_stack(scope, receive, send)

/opt/homebrew/Caskroom/miniconda/base/lib/python3.11/site-packages/starlette/routing.py:756: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <fastapi.routing.APIRouter object at 0x119bf7ad0>
scope = {'app': <fastapi.applications.FastAPI object at 0x119bf5710>, 'asgi': {'version': '3.0'}, 'client': ('127.0.0.1', 123), 'endpoint': <function create_orders_batch at 0x1191c7380>, ...}
receive = <function ASGITransport.handle_async_request.<locals>.receive at 0x119fb0f40>
send = <function wrap_app_handling_exceptions.<locals>.wrapped_app.<locals>.sender at 0x11c454540>

    async def app(self, scope: Scope, receive: Receive, send: Send) -> None:
        assert scope["type"] in ("http", "websocket", "lifespan")
    
        if "router" not in scope:
            scope["router"] = self
    
        if scope["type"] == "lifespan":
            await self.lifespan(scope, receive, send)
            return
    
        partial = None
    
        for route in self.routes:
            # Determine if any route matches the incoming scope,
            # and hand over to the matching route if found.
            match, child_scope = route.matches(scope)
            if match == Match.FULL:
                scope.update(child_scope)
>               await route.handle(scope, receive, send)

/opt/homebrew/Caskroom/miniconda/base/lib/python3.11/site-packages/starlette/routing.py:776: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = APIRoute(path='/api/v1/contractors/orders', name='create_orders_batch', methods=['POST'])
scope = {'app': <fastapi.applications.FastAPI object at 0x119bf5710>, 'asgi': {'version': '3.0'}, 'client': ('127.0.0.1', 123), 'endpoint': <function create_orders_batch at 0x1191c7380>, ...}
receive = <function ASGITransport.handle_async_request.<locals>.receive at 0x119fb0f40>
send = <function wrap_app_handling_exceptions.<locals>.wrapped_app.<locals>.sender at 0x11c454540>

    async def handle(self, scope: Scope, receive: Receive, send: Send) -> None:
        if self.methods and scope["method"] not in self.methods:
            headers = {"Allow": ", ".join(self.methods)}
            if "app" in scope:
                raise HTTPException(status_code=405, headers=headers)
            else:
                response = PlainTextResponse(
                    "Method Not Allowed", status_code=405, headers=headers
                )
            await response(scope, receive, send)
        else:
>           await self.app(scope, receive, send)

/opt/homebrew/Caskroom/miniconda/base/lib/python3.11/site-packages/starlette/routing.py:297: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

scope = {'app': <fastapi.applications.FastAPI object at 0x119bf5710>, 'asgi': {'version': '3.0'}, 'client': ('127.0.0.1', 123), 'endpoint': <function create_orders_batch at 0x1191c7380>, ...}
receive = <function ASGITransport.handle_async_request.<locals>.receive at 0x119fb0f40>
send = <function wrap_app_handling_exceptions.<locals>.wrapped_app.<locals>.sender at 0x11c454540>

    async def app(scope: Scope, receive: Receive, send: Send) -> None:
        request = Request(scope, receive, send)
    
        async def app(scope: Scope, receive: Receive, send: Send) -> None:
            if is_async_callable(func):
                response = await func(request)
            else:
                response = await run_in_threadpool(func, request)
            await response(scope, receive, send)
    
>       await wrap_app_handling_exceptions(app, request)(scope, receive, send)

/opt/homebrew/Caskroom/miniconda/base/lib/python3.11/site-packages/starlette/routing.py:77: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

scope = {'app': <fastapi.applications.FastAPI object at 0x119bf5710>, 'asgi': {'version': '3.0'}, 'client': ('127.0.0.1', 123), 'endpoint': <function create_orders_batch at 0x1191c7380>, ...}
receive = <function ASGITransport.handle_async_request.<locals>.receive at 0x119fb0f40>
send = <function wrap_app_handling_exceptions.<locals>.wrapped_app.<locals>.sender at 0x11c454540>

    async def wrapped_app(scope: Scope, receive: Receive, send: Send) -> None:
        response_started = False
    
        async def sender(message: Message) -> None:
            nonlocal response_started
    
            if message["type"] == "http.response.start":
                response_started = True
            await send(message)
    
        try:
            await app(scope, receive, sender)
        except Exception as exc:
            handler = None
    
            if isinstance(exc, HTTPException):
                handler = status_handlers.get(exc.status_code)
    
            if handler is None:
                handler = _lookup_exception_handler(exception_handlers, exc)
    
            if handler is None:
>               raise exc

/opt/homebrew/Caskroom/miniconda/base/lib/python3.11/site-packages/starlette/_exception_handler.py:64: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

scope = {'app': <fastapi.applications.FastAPI object at 0x119bf5710>, 'asgi': {'version': '3.0'}, 'client': ('127.0.0.1', 123), 'endpoint': <function create_orders_batch at 0x1191c7380>, ...}
receive = <function ASGITransport.handle_async_request.<locals>.receive at 0x119fb0f40>
send = <function wrap_app_handling_exceptions.<locals>.wrapped_app.<locals>.sender at 0x11c454540>

    async def wrapped_app(scope: Scope, receive: Receive, send: Send) -> None:
        response_started = False
    
        async def sender(message: Message) -> None:
            nonlocal response_started
    
            if message["type"] == "http.response.start":
                response_started = True
            await send(message)
    
        try:
>           await app(scope, receive, sender)

/opt/homebrew/Caskroom/miniconda/base/lib/python3.11/site-packages/starlette/_exception_handler.py:53: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

scope = {'app': <fastapi.applications.FastAPI object at 0x119bf5710>, 'asgi': {'version': '3.0'}, 'client': ('127.0.0.1', 123), 'endpoint': <function create_orders_batch at 0x1191c7380>, ...}
receive = <function ASGITransport.handle_async_request.<locals>.receive at 0x119fb0f40>
send = <function wrap_app_handling_exceptions.<locals>.wrapped_app.<locals>.sender at 0x11c456660>

    async def app(scope: Scope, receive: Receive, send: Send) -> None:
        if is_async_callable(func):
>           response = await func(request)
                       ^^^^^^^^^^^^^^^^^^^

/opt/homebrew/Caskroom/miniconda/base/lib/python3.11/site-packages/starlette/routing.py:72: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <starlette.requests.Request object at 0x11c78a750>

    async def app(request: Request) -> Response:
        response: Union[Response, None] = None
        async with AsyncExitStack() as file_stack:
            try:
                body: Any = None
                if body_field:
                    if is_body_form:
                        body = await request.form()
                        file_stack.push_async_callback(body.close)
                    else:
                        body_bytes = await request.body()
                        if body_bytes:
                            json_body: Any = Undefined
                            content_type_value = request.headers.get("content-type")
                            if not content_type_value:
                                json_body = await request.json()
                            else:
                                message = email.message.Message()
                                message["content-type"] = content_type_value
                                if message.get_content_maintype() == "application":
                                    subtype = message.get_content_subtype()
                                    if subtype == "json" or subtype.endswith("+json"):
                                        json_body = await request.json()
                            if json_body != Undefined:
                                body = json_body
                            else:
                                body = body_bytes
            except json.JSONDecodeError as e:
                validation_error = RequestValidationError(
                    [
                        {
                            "type": "json_invalid",
                            "loc": ("body", e.pos),
                            "msg": "JSON decode error",
                            "input": {},
                            "ctx": {"error": e.msg},
                        }
                    ],
                    body=e.doc,
                )
                raise validation_error from e
            except HTTPException:
                # If a middleware raises an HTTPException, it should be raised again
                raise
            except Exception as e:
                http_error = HTTPException(
                    status_code=400, detail="There was an error parsing the body"
                )
                raise http_error from e
            errors: List[Any] = []
            async with AsyncExitStack() as async_exit_stack:
>               solved_result = await solve_dependencies(
                    request=request,
                    dependant=dependant,
                    body=body,
                    dependency_overrides_provider=dependency_overrides_provider,
                    async_exit_stack=async_exit_stack,
                )

/opt/homebrew/Caskroom/miniconda/base/lib/python3.11/site-packages/fastapi/routing.py:269: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    async def solve_dependencies(
        *,
        request: Union[Request, WebSocket],
        dependant: Dependant,
        body: Optional[Union[Dict[str, Any], FormData]] = None,
        background_tasks: Optional[StarletteBackgroundTasks] = None,
        response: Optional[Response] = None,
        dependency_overrides_provider: Optional[Any] = None,
        dependency_cache: Optional[Dict[Tuple[Callable[..., Any], Tuple[str]], Any]] = None,
        async_exit_stack: AsyncExitStack,
    ) -> Tuple[
        Dict[str, Any],
        List[Any],
        Optional[StarletteBackgroundTasks],
        Response,
        Dict[Tuple[Callable[..., Any], Tuple[str]], Any],
    ]:
        values: Dict[str, Any] = {}
        errors: List[Any] = []
        if response is None:
            response = Response()
            del response.headers["content-length"]
            response.status_code = None  # type: ignore
        dependency_cache = dependency_cache or {}
        sub_dependant: Dependant
        for sub_dependant in dependant.dependencies:
            sub_dependant.call = cast(Callable[..., Any], sub_dependant.call)
            sub_dependant.cache_key = cast(
                Tuple[Callable[..., Any], Tuple[str]], sub_dependant.cache_key
            )
            call = sub_dependant.call
            use_sub_dependant = sub_dependant
            if (
                dependency_overrides_provider
                and dependency_overrides_provider.dependency_overrides
            ):
                original_call = sub_dependant.call
                call = getattr(
                    dependency_overrides_provider, "dependency_overrides", {}
                ).get(original_call, original_call)
                use_path: str = sub_dependant.path  # type: ignore
                use_sub_dependant = get_dependant(
                    path=use_path,
                    call=call,
                    name=sub_dependant.name,
                    security_scopes=sub_dependant.security_scopes,
                )
    
            solved_result = await solve_dependencies(
                request=request,
                dependant=use_sub_dependant,
                body=body,
                background_tasks=background_tasks,
                response=response,
                dependency_overrides_provider=dependency_overrides_provider,
                dependency_cache=dependency_cache,
                async_exit_stack=async_exit_stack,
            )
            (
                sub_values,
                sub_errors,
                background_tasks,
                _,  # the subdependency returns the same response we have
                sub_dependency_cache,
            ) = solved_result
            dependency_cache.update(sub_dependency_cache)
            if sub_errors:
                errors.extend(sub_errors)
                continue
            if sub_dependant.use_cache and sub_dependant.cache_key in dependency_cache:
                solved = dependency_cache[sub_dependant.cache_key]
            elif is_gen_callable(call) or is_async_gen_callable(call):
                solved = await solve_generator(
                    call=call, stack=async_exit_stack, sub_values=sub_values
                )
            elif is_coroutine_callable(call):
>               solved = await call(**sub_values)
                         ^^^^^^^^^^^^^^^^^^^^^^^^

/opt/homebrew/Caskroom/miniconda/base/lib/python3.11/site-packages/fastapi/dependencies/utils.py:600: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

api_key = 'wrong-key'
session = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x11c7881d0>

    async def get_contractor(
        api_key: str = Security(api_key_header),
        session: AsyncSession = Depends(get_db)
    ) -> Contractor:
        """Проверка API ключа подрядчика."""
        query = select(Contractor).where(Contractor.api_key == api_key, Contractor.is_active == True)
>       result = await session.execute(query)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^

src/api/contractors.py:29: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.ext.asyncio.session.AsyncSession object at 0x11c7881d0>
statement = <sqlalchemy.sql.selectable.Select object at 0x11c789990>
params = None, execution_options = immutabledict({'prebuffer_rows': True})
bind_arguments = None, kw = {}

    async def execute(
        self,
        statement: Executable,
        params: Optional[_CoreAnyExecuteParams] = None,
        *,
        execution_options: OrmExecuteOptionsParameter = util.EMPTY_DICT,
        bind_arguments: Optional[_BindArguments] = None,
        **kw: Any,
    ) -> Result[Any]:
        """Execute a statement and return a buffered
        :class:`_engine.Result` object.
    
        .. seealso::
    
            :meth:`_orm.Session.execute` - main documentation for execute
    
        """
    
        if execution_options:
            execution_options = util.immutabledict(execution_options).union(
                _EXECUTE_OPTIONS
            )
        else:
            execution_options = _EXECUTE_OPTIONS
    
>       result = await greenlet_spawn(
            self.sync_session.execute,
            statement,
            params=params,
            execution_options=execution_options,
            bind_arguments=bind_arguments,
            **kw,
        )

/opt/homebrew/Caskroom/miniconda/base/lib/python3.11/site-packages/sqlalchemy/ext/asyncio/session.py:449: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <bound method Session.execute of <sqlalchemy.orm.session.Session object at 0x11c788850>>
_require_await = False
args = (<sqlalchemy.sql.selectable.Select object at 0x11c789990>,)
kwargs = {'bind_arguments': None, 'execution_options': immutabledict({'prebuffer_rows': True}), 'params': None}
context = <_AsyncIoGreenlet object at 0x11c789a40 (otid=0x1069dacd0) dead>
switch_occurred = True
result = <Future finished exception=RuntimeError('Event loop is closed')>

    async def greenlet_spawn(
        fn: Callable[..., _T],
        *args: Any,
        _require_await: bool = False,
        **kwargs: Any,
    ) -> _T:
        """Runs a sync function ``fn`` in a new greenlet.
    
        The sync function can then use :func:`await_only` to wait for async
        functions.
    
        :param fn: The sync callable to call.
        :param \\*args: Positional arguments to pass to the ``fn`` callable.
        :param \\*\\*kwargs: Keyword arguments to pass to the ``fn`` callable.
        """
    
        result: Any
        context = _AsyncIoGreenlet(fn, getcurrent())
        # runs the function synchronously in gl greenlet. If the execution
        # is interrupted by await_only, context is not dead and result is a
        # coroutine to wait. If the context is dead the function has
        # returned, and its result can be returned.
        switch_occurred = False
        result = context.switch(*args, **kwargs)
        while not context.dead:
            switch_occurred = True
            try:
                # wait for a coroutine from await_only and then return its
                # result back to it.
                value = await result
            except BaseException:
                # this allows an exception to be raised within
                # the moderated greenlet so that it can continue
                # its expected flow.
>               result = context.throw(*sys.exc_info())
                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/opt/homebrew/Caskroom/miniconda/base/lib/python3.11/site-packages/sqlalchemy/util/_concurrency_py3k.py:201: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.Session object at 0x11c788850>
statement = <sqlalchemy.sql.selectable.Select object at 0x11c789990>
params = None

    def execute(
        self,
        statement: Executable,
        params: Optional[_CoreAnyExecuteParams] = None,
        *,
        execution_options: OrmExecuteOptionsParameter = util.EMPTY_DICT,
        bind_arguments: Optional[_BindArguments] = None,
        _parent_execute_state: Optional[Any] = None,
        _add_event: Optional[Any] = None,
    ) -> Result[Any]:
        r"""Execute a SQL expression construct.
    
        Returns a :class:`_engine.Result` object representing
        results of the statement execution.
    
        E.g.::
    
            from sqlalchemy import select
    
            result = session.execute(select(User).where(User.id == 5))
    
        The API contract of :meth:`_orm.Session.execute` is similar to that
        of :meth:`_engine.Connection.execute`, the :term:`2.0 style` version
        of :class:`_engine.Connection`.
    
        .. versionchanged:: 1.4 the :meth:`_orm.Session.execute` method is
           now the primary point of ORM statement execution when using
           :term:`2.0 style` ORM usage.
    
        :param statement:
            An executable statement (i.e. an :class:`.Executable` expression
            such as :func:`_expression.select`).
    
        :param params:
            Optional dictionary, or list of dictionaries, containing
            bound parameter values.   If a single dictionary, single-row
            execution occurs; if a list of dictionaries, an
            "executemany" will be invoked.  The keys in each dictionary
            must correspond to parameter names present in the statement.
    
        :param execution_options: optional dictionary of execution options,
         which will be associated with the statement execution.  This
         dictionary can provide a subset of the options that are accepted
         by :meth:`_engine.Connection.execution_options`, and may also
         provide additional options understood only in an ORM context.
    
         .. seealso::
    
            :ref:`orm_queryguide_execution_options` - ORM-specific execution
            options
    
        :param bind_arguments: dictionary of additional arguments to determine
         the bind.  May include "mapper", "bind", or other custom arguments.
         Contents of this dictionary are passed to the
         :meth:`.Session.get_bind` method.
    
        :return: a :class:`_engine.Result` object.
    
    
        """
>       return self._execute_internal(
            statement,
            params,
            execution_options=execution_options,
            bind_arguments=bind_arguments,
            _parent_execute_state=_parent_execute_state,
            _add_event=_add_event,
        )

/opt/homebrew/Caskroom/miniconda/base/lib/python3.11/site-packages/sqlalchemy/orm/session.py:2351: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.Session object at 0x11c788850>
statement = <sqlalchemy.sql.selectable.Select object at 0x11c789990>
params = None

    def _execute_internal(
        self,
        statement: Executable,
        params: Optional[_CoreAnyExecuteParams] = None,
        *,
        execution_options: OrmExecuteOptionsParameter = util.EMPTY_DICT,
        bind_arguments: Optional[_BindArguments] = None,
        _parent_execute_state: Optional[Any] = None,
        _add_event: Optional[Any] = None,
        _scalar_result: bool = False,
    ) -> Any:
        statement = coercions.expect(roles.StatementRole, statement)
    
        if not bind_arguments:
            bind_arguments = {}
        else:
            bind_arguments = dict(bind_arguments)
    
        if (
            statement._propagate_attrs.get("compile_state_plugin", None)
            == "orm"
        ):
            compile_state_cls = CompileState._get_plugin_class_for_plugin(
                statement, "orm"
            )
            if TYPE_CHECKING:
                assert isinstance(
                    compile_state_cls, context.AbstractORMCompileState
                )
        else:
            compile_state_cls = None
            bind_arguments.setdefault("clause", statement)
    
        execution_options = util.coerce_to_immutabledict(execution_options)
    
        if _parent_execute_state:
            events_todo = _parent_execute_state._remaining_events()
        else:
            events_todo = self.dispatch.do_orm_execute
            if _add_event:
                events_todo = list(events_todo) + [_add_event]
    
        if events_todo:
            if compile_state_cls is not None:
                # for event handlers, do the orm_pre_session_exec
                # pass ahead of the event handlers, so that things like
                # .load_options, .update_delete_options etc. are populated.
                # is_pre_event=True allows the hook to hold off on things
                # it doesn't want to do twice, including autoflush as well
                # as "pre fetch" for DML, etc.
                (
                    statement,
                    execution_options,
                ) = compile_state_cls.orm_pre_session_exec(
                    self,
                    statement,
                    params,
                    execution_options,
                    bind_arguments,
                    True,
                )
    
            orm_exec_state = ORMExecuteState(
                self,
                statement,
                params,
                execution_options,
                bind_arguments,
                compile_state_cls,
                events_todo,
            )
            for idx, fn in enumerate(events_todo):
                orm_exec_state._starting_event_idx = idx
                fn_result: Optional[Result[Any]] = fn(orm_exec_state)
                if fn_result:
                    if _scalar_result:
                        return fn_result.scalar()
                    else:
                        return fn_result
    
            statement = orm_exec_state.statement
            execution_options = orm_exec_state.local_execution_options
    
        if compile_state_cls is not None:
            # now run orm_pre_session_exec() "for real".   if there were
            # event hooks, this will re-run the steps that interpret
            # new execution_options into load_options / update_delete_options,
            # which we assume the event hook might have updated.
            # autoflush will also be invoked in this step if enabled.
            (
                statement,
                execution_options,
            ) = compile_state_cls.orm_pre_session_exec(
                self,
                statement,
                params,
                execution_options,
                bind_arguments,
                False,
            )
    
        bind = self.get_bind(**bind_arguments)
    
>       conn = self._connection_for_bind(bind)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/opt/homebrew/Caskroom/miniconda/base/lib/python3.11/site-packages/sqlalchemy/orm/session.py:2239: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.Session object at 0x11c788850>
engine = Engine(postgresql+asyncpg://tms:***@localhost:5432/tms_db)
execution_options = None, kw = {}
trans = <sqlalchemy.orm.session.SessionTransaction object at 0x11ad51590>

    def _connection_for_bind(
        self,
        engine: _SessionBind,
        execution_options: Optional[CoreExecuteOptionsParameter] = None,
        **kw: Any,
    ) -> Connection:
        TransactionalContext._trans_ctx_check(self)
    
        trans = self._transaction
        if trans is None:
            trans = self._autobegin_t()
>       return trans._connection_for_bind(engine, execution_options)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/opt/homebrew/Caskroom/miniconda/base/lib/python3.11/site-packages/sqlalchemy/orm/session.py:2108: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.SessionTransaction object at 0x11ad51590>
bind = Engine(postgresql+asyncpg://tms:***@localhost:5432/tms_db)
execution_options = None

>   ???

<string>:2: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function SessionTransaction._connection_for_bind at 0x10855c220>
self = <sqlalchemy.orm.session.SessionTransaction object at 0x11ad51590>
arg = (Engine(postgresql+asyncpg://tms:***@localhost:5432/tms_db), None)
kw = {}, current_state = <SessionTransactionState.ACTIVE: 1>
next_state = <_StateChangeStates.ANY: 1>, existing_fn = None
expect_state = <SessionTransactionState.ACTIVE: 1>

    @util.decorator
    def _go(fn: _F, self: Any, *arg: Any, **kw: Any) -> Any:
        current_state = self._state
    
        if (
            has_prerequisite_states
            and current_state not in prerequisite_state_collection
        ):
            self._raise_for_prerequisite_state(fn.__name__, current_state)
    
        next_state = self._next_state
        existing_fn = self._current_fn
        expect_state = moves_to if expect_state_change else current_state
    
        if (
            # destination states are restricted
            next_state is not _StateChangeStates.ANY
            # method seeks to change state
            and expect_state_change
            # destination state incorrect
            and next_state is not expect_state
        ):
            if existing_fn and next_state in (
                _StateChangeStates.NO_CHANGE,
                _StateChangeStates.CHANGE_IN_PROGRESS,
            ):
                raise sa_exc.IllegalStateChangeError(
                    f"Method '{fn.__name__}()' can't be called here; "
                    f"method '{existing_fn.__name__}()' is already "
                    f"in progress and this would cause an unexpected "
                    f"state change to {moves_to!r}",
                    code="isce",
                )
            else:
                raise sa_exc.IllegalStateChangeError(
                    f"Cant run operation '{fn.__name__}()' here; "
                    f"will move to state {moves_to!r} where we are "
                    f"expecting {next_state!r}",
                    code="isce",
                )
    
        self._current_fn = fn
        self._next_state = _StateChangeStates.CHANGE_IN_PROGRESS
        try:
>           ret_value = fn(self, *arg, **kw)
                        ^^^^^^^^^^^^^^^^^^^^

/opt/homebrew/Caskroom/miniconda/base/lib/python3.11/site-packages/sqlalchemy/orm/state_changes.py:137: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.SessionTransaction object at 0x11ad51590>
bind = Engine(postgresql+asyncpg://tms:***@localhost:5432/tms_db)
execution_options = None

    @_StateChange.declare_states(
        (SessionTransactionState.ACTIVE,), _StateChangeStates.NO_CHANGE
    )
    def _connection_for_bind(
        self,
        bind: _SessionBind,
        execution_options: Optional[CoreExecuteOptionsParameter],
    ) -> Connection:
        if bind in self._connections:
            if execution_options:
                util.warn(
                    "Connection is already established for the "
                    "given bind; execution_options ignored"
                )
            return self._connections[bind][0]
    
        self._state = SessionTransactionState.PROVISIONING_CONNECTION
    
        local_connect = False
        should_commit = True
    
        try:
            if self._parent:
                conn = self._parent._connection_for_bind(
                    bind, execution_options
                )
                if not self.nested:
                    return conn
            else:
                if isinstance(bind, engine.Connection):
                    conn = bind
                    if conn.engine in self._connections:
                        raise sa_exc.InvalidRequestError(
                            "Session already has a Connection associated "
                            "for the given Connection's Engine"
                        )
                else:
>                   conn = bind.connect()
                           ^^^^^^^^^^^^^^

/opt/homebrew/Caskroom/miniconda/base/lib/python3.11/site-packages/sqlalchemy/orm/session.py:1187: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Engine(postgresql+asyncpg://tms:***@localhost:5432/tms_db)

    def connect(self) -> Connection:
        """Return a new :class:`_engine.Connection` object.
    
        The :class:`_engine.Connection` acts as a Python context manager, so
        the typical use of this method looks like::
    
            with engine.connect() as connection:
                connection.execute(text("insert into table values ('foo')"))
                connection.commit()
    
        Where above, after the block is completed, the connection is "closed"
        and its underlying DBAPI resources are returned to the connection pool.
        This also has the effect of rolling back any transaction that
        was explicitly begun or was begun via autobegin, and will
        emit the :meth:`_events.ConnectionEvents.rollback` event if one was
        started and is still in progress.
    
        .. seealso::
    
            :meth:`_engine.Engine.begin`
    
        """
    
>       return self._connection_cls(self)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^

/opt/homebrew/Caskroom/miniconda/base/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3285: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x11c789650>
engine = Engine(postgresql+asyncpg://tms:***@localhost:5432/tms_db)
connection = None, _has_events = None, _allow_revalidate = True
_allow_autobegin = True

    def __init__(
        self,
        engine: Engine,
        connection: Optional[PoolProxiedConnection] = None,
        _has_events: Optional[bool] = None,
        _allow_revalidate: bool = True,
        _allow_autobegin: bool = True,
    ):
        """Construct a new Connection."""
        self.engine = engine
        self.dialect = dialect = engine.dialect
    
        if connection is None:
            try:
>               self._dbapi_connection = engine.raw_connection()
                                         ^^^^^^^^^^^^^^^^^^^^^^^

/opt/homebrew/Caskroom/miniconda/base/lib/python3.11/site-packages/sqlalchemy/engine/base.py:143: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Engine(postgresql+asyncpg://tms:***@localhost:5432/tms_db)

    def raw_connection(self) -> PoolProxiedConnection:
        """Return a "raw" DBAPI connection from the connection pool.
    
        The returned object is a proxied version of the DBAPI
        connection object used by the underlying driver in use.
        The object will have all the same behavior as the real DBAPI
        connection, except that its ``close()`` method will result in the
        connection being returned to the pool, rather than being closed
        for real.
    
        This method provides direct DBAPI connection access for
        special situations when the API provided by
        :class:`_engine.Connection`
        is not needed.   When a :class:`_engine.Connection` object is already
        present, the DBAPI connection is available using
        the :attr:`_engine.Connection.connection` accessor.
    
        .. seealso::
    
            :ref:`dbapi_connections`
    
        """
>       return self.pool.connect()
               ^^^^^^^^^^^^^^^^^^^

/opt/homebrew/Caskroom/miniconda/base/lib/python3.11/site-packages/sqlalchemy/engine/base.py:3309: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.pool.impl.AsyncAdaptedQueuePool object at 0x108a0a250>

    def connect(self) -> PoolProxiedConnection:
        """Return a DBAPI connection from the pool.
    
        The connection is instrumented such that when its
        ``close()`` method is called, the connection will be returned to
        the pool.
    
        """
>       return _ConnectionFairy._checkout(self)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/opt/homebrew/Caskroom/miniconda/base/lib/python3.11/site-packages/sqlalchemy/pool/base.py:447: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'sqlalchemy.pool.base._ConnectionFairy'>
pool = <sqlalchemy.pool.impl.AsyncAdaptedQueuePool object at 0x108a0a250>
threadconns = None

    @classmethod
    def _checkout(
        cls,
        pool: Pool,
        threadconns: Optional[threading.local] = None,
        fairy: Optional[_ConnectionFairy] = None,
    ) -> _ConnectionFairy:
        if not fairy:
            fairy = _ConnectionRecord.checkout(pool)
    
            if threadconns is not None:
                threadconns.current = weakref.ref(fairy)
    
        assert (
            fairy._connection_record is not None
        ), "can't 'checkout' a detached connection fairy"
        assert (
            fairy.dbapi_connection is not None
        ), "can't 'checkout' an invalidated connection fairy"
    
        fairy._counter += 1
        if (
            not pool.dispatch.checkout and not pool._pre_ping
        ) or fairy._counter != 1:
            return fairy
    
        # Pool listeners can trigger a reconnection on checkout, as well
        # as the pre-pinger.
        # there are three attempts made here, but note that if the database
        # is not accessible from a connection standpoint, those won't proceed
        # here.
    
        attempts = 2
    
        while attempts > 0:
            connection_is_fresh = fairy._connection_record.fresh
            fairy._connection_record.fresh = False
            try:
                if pool._pre_ping:
                    if not connection_is_fresh:
                        if fairy._echo:
                            pool.logger.debug(
                                "Pool pre-ping on connection %s",
                                fairy.dbapi_connection,
                            )
                        result = pool._dialect._do_ping_w_event(
                            fairy.dbapi_connection
                        )
                        if not result:
                            if fairy._echo:
                                pool.logger.debug(
                                    "Pool pre-ping on connection %s failed, "
                                    "will invalidate pool",
                                    fairy.dbapi_connection,
                                )
                            raise exc.InvalidatePoolError()
                    elif fairy._echo:
                        pool.logger.debug(
                            "Connection %s is fresh, skipping pre-ping",
                            fairy.dbapi_connection,
                        )
    
                pool.dispatch.checkout(
                    fairy.dbapi_connection, fairy._connection_record, fairy
                )
                return fairy
            except exc.DisconnectionError as e:
                if e.invalidate_pool:
                    pool.logger.info(
                        "Disconnection detected on checkout, "
                        "invalidating all pooled connections prior to "
                        "current timestamp (reason: %r)",
                        e,
                    )
                    fairy._connection_record.invalidate(e)
                    pool._invalidate(fairy, e, _checkin=False)
                else:
                    pool.logger.info(
                        "Disconnection detected on checkout, "
                        "invalidating individual connection %s (reason: %r)",
                        fairy.dbapi_connection,
                        e,
                    )
                    fairy._connection_record.invalidate(e)
                try:
                    fairy.dbapi_connection = (
                        fairy._connection_record.get_connection()
                    )
                except BaseException as err:
                    with util.safe_reraise():
                        fairy._connection_record._checkin_failed(
                            err,
                            _fairy_was_created=True,
                        )
    
                        # prevent _ConnectionFairy from being carried
                        # in the stack trace.  Do this after the
                        # connection record has been checked in, so that
                        # if the del triggers a finalize fairy, it won't
                        # try to checkin a second time.
                        del fairy
    
                    # never called, this is for code linters
                    raise
    
                attempts -= 1
            except BaseException as be_outer:
>               with util.safe_reraise():

/opt/homebrew/Caskroom/miniconda/base/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1363: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.util.langhelpers.safe_reraise object at 0x11ad90fa0>
type_ = None, value = None, traceback = None

    def __exit__(
        self,
        type_: Optional[Type[BaseException]],
        value: Optional[BaseException],
        traceback: Optional[types.TracebackType],
    ) -> NoReturn:
        assert self._exc_info is not None
        # see #2703 for notes
        if type_ is None:
            exc_type, exc_value, exc_tb = self._exc_info
            assert exc_value is not None
            self._exc_info = None  # remove potential circular references
>           raise exc_value.with_traceback(exc_tb)

/opt/homebrew/Caskroom/miniconda/base/lib/python3.11/site-packages/sqlalchemy/util/langhelpers.py:224: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <class 'sqlalchemy.pool.base._ConnectionFairy'>
pool = <sqlalchemy.pool.impl.AsyncAdaptedQueuePool object at 0x108a0a250>
threadconns = None

    @classmethod
    def _checkout(
        cls,
        pool: Pool,
        threadconns: Optional[threading.local] = None,
        fairy: Optional[_ConnectionFairy] = None,
    ) -> _ConnectionFairy:
        if not fairy:
            fairy = _ConnectionRecord.checkout(pool)
    
            if threadconns is not None:
                threadconns.current = weakref.ref(fairy)
    
        assert (
            fairy._connection_record is not None
        ), "can't 'checkout' a detached connection fairy"
        assert (
            fairy.dbapi_connection is not None
        ), "can't 'checkout' an invalidated connection fairy"
    
        fairy._counter += 1
        if (
            not pool.dispatch.checkout and not pool._pre_ping
        ) or fairy._counter != 1:
            return fairy
    
        # Pool listeners can trigger a reconnection on checkout, as well
        # as the pre-pinger.
        # there are three attempts made here, but note that if the database
        # is not accessible from a connection standpoint, those won't proceed
        # here.
    
        attempts = 2
    
        while attempts > 0:
            connection_is_fresh = fairy._connection_record.fresh
            fairy._connection_record.fresh = False
            try:
                if pool._pre_ping:
                    if not connection_is_fresh:
                        if fairy._echo:
                            pool.logger.debug(
                                "Pool pre-ping on connection %s",
                                fairy.dbapi_connection,
                            )
>                       result = pool._dialect._do_ping_w_event(
                            fairy.dbapi_connection
                        )

/opt/homebrew/Caskroom/miniconda/base/lib/python3.11/site-packages/sqlalchemy/pool/base.py:1301: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.asyncpg.PGDialect_asyncpg object at 0x10897ef10>
dbapi_connection = <AdaptedConnection <asyncpg.connection.Connection object at 0x119fec8b0>>

    def _do_ping_w_event(self, dbapi_connection: DBAPIConnection) -> bool:
        try:
>           return self.do_ping(dbapi_connection)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/opt/homebrew/Caskroom/miniconda/base/lib/python3.11/site-packages/sqlalchemy/engine/default.py:729: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.postgresql.asyncpg.PGDialect_asyncpg object at 0x10897ef10>
dbapi_connection = <AdaptedConnection <asyncpg.connection.Connection object at 0x119fec8b0>>

    def do_ping(self, dbapi_connection):
>       dbapi_connection.ping()

/opt/homebrew/Caskroom/miniconda/base/lib/python3.11/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:1160: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <AdaptedConnection <asyncpg.connection.Connection object at 0x119fec8b0>>

    def ping(self):
        try:
            _ = self.await_(self._async_ping())
        except Exception as error:
>           self._handle_exception(error)

/opt/homebrew/Caskroom/miniconda/base/lib/python3.11/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:818: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <AdaptedConnection <asyncpg.connection.Connection object at 0x119fec8b0>>
error = RuntimeError("Task <Task pending name='Task-29' coro=<test_contractor_invalid_api_key() running at /Users/alsmolentsev...io/base_events.py:181]> got Future <Future pending cb=[Protocol._on_waiter_completed()]> attached to a different loop")

    def _handle_exception(self, error):
        if self._connection.is_closed():
            self._transaction = None
            self._started = False
    
        if not isinstance(error, AsyncAdapt_asyncpg_dbapi.Error):
            exception_mapping = self.dbapi._asyncpg_error_translate
    
            for super_ in type(error).__mro__:
                if super_ in exception_mapping:
                    translated_error = exception_mapping[super_](
                        "%s: %s" % (type(error), error)
                    )
                    translated_error.pgcode = translated_error.sqlstate = (
                        getattr(error, "sqlstate", None)
                    )
                    raise translated_error from error
            else:
>               raise error

/opt/homebrew/Caskroom/miniconda/base/lib/python3.11/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:799: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <AdaptedConnection <asyncpg.connection.Connection object at 0x119fec8b0>>

    def ping(self):
        try:
>           _ = self.await_(self._async_ping())
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/opt/homebrew/Caskroom/miniconda/base/lib/python3.11/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:816: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

awaitable = <coroutine object AsyncAdapt_asyncpg_connection._async_ping at 0x11a3f5700>

    def await_only(awaitable: Awaitable[_T]) -> _T:
        """Awaits an async function in a sync method.
    
        The sync method must be inside a :func:`greenlet_spawn` context.
        :func:`await_only` calls cannot be nested.
    
        :param awaitable: The coroutine to call.
    
        """
        # this is called in the context greenlet while running fn
        current = getcurrent()
        if not getattr(current, "__sqlalchemy_greenlet_provider__", False):
            _safe_cancel_awaitable(awaitable)
    
            raise exc.MissingGreenlet(
                "greenlet_spawn has not been called; can't call await_only() "
                "here. Was IO attempted in an unexpected place?"
            )
    
        # returns the control to the driver greenlet passing it
        # a coroutine to run. Once the awaitable is done, the driver greenlet
        # switches back to this greenlet with the result of awaitable that is
        # then returned to the caller (or raised as error)
>       return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/opt/homebrew/Caskroom/miniconda/base/lib/python3.11/site-packages/sqlalchemy/util/_concurrency_py3k.py:132: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <bound method Session.execute of <sqlalchemy.orm.session.Session object at 0x11c788850>>
_require_await = False
args = (<sqlalchemy.sql.selectable.Select object at 0x11c789990>,)
kwargs = {'bind_arguments': None, 'execution_options': immutabledict({'prebuffer_rows': True}), 'params': None}
context = <_AsyncIoGreenlet object at 0x11c789a40 (otid=0x1069dacd0) dead>
switch_occurred = True
result = <Future finished exception=RuntimeError('Event loop is closed')>

    async def greenlet_spawn(
        fn: Callable[..., _T],
        *args: Any,
        _require_await: bool = False,
        **kwargs: Any,
    ) -> _T:
        """Runs a sync function ``fn`` in a new greenlet.
    
        The sync function can then use :func:`await_only` to wait for async
        functions.
    
        :param fn: The sync callable to call.
        :param \\*args: Positional arguments to pass to the ``fn`` callable.
        :param \\*\\*kwargs: Keyword arguments to pass to the ``fn`` callable.
        """
    
        result: Any
        context = _AsyncIoGreenlet(fn, getcurrent())
        # runs the function synchronously in gl greenlet. If the execution
        # is interrupted by await_only, context is not dead and result is a
        # coroutine to wait. If the context is dead the function has
        # returned, and its result can be returned.
        switch_occurred = False
        result = context.switch(*args, **kwargs)
        while not context.dead:
            switch_occurred = True
            try:
                # wait for a coroutine from await_only and then return its
                # result back to it.
>               value = await result
                        ^^^^^^^^^^^^

/opt/homebrew/Caskroom/miniconda/base/lib/python3.11/site-packages/sqlalchemy/util/_concurrency_py3k.py:196: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <AdaptedConnection <asyncpg.connection.Connection object at 0x119fec8b0>>

    async def _async_ping(self):
        if self._transaction is None and self.isolation_level != "autocommit":
            # create a tranasction explicitly to support pgbouncer
            # transaction mode.   See #10226
            tr = self._connection.transaction()
>           await tr.start()

/opt/homebrew/Caskroom/miniconda/base/lib/python3.11/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py:825: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <asyncpg.Transaction state:failed 0x11c8f94d0>

    @connresource.guarded
    async def start(self):
        """Enter the transaction or savepoint block."""
        self.__check_state_base('start')
        if self._state is TransactionState.STARTED:
            raise apg_errors.InterfaceError(
                'cannot start; the transaction is already started')
    
        con = self._connection
    
        if con._top_xact is None:
            if con._protocol.is_in_transaction():
                raise apg_errors.InterfaceError(
                    'cannot use Connection.transaction() in '
                    'a manually started transaction')
            con._top_xact = self
        else:
            # Nested transaction block
            if self._isolation:
                top_xact_isolation = con._top_xact._isolation
                if top_xact_isolation is None:
                    top_xact_isolation = ISOLATION_LEVELS_BY_VALUE[
                        await self._connection.fetchval(
                            'SHOW transaction_isolation;')]
                if self._isolation != top_xact_isolation:
                    raise apg_errors.InterfaceError(
                        'nested transaction has a different isolation level: '
                        'current {!r} != outer {!r}'.format(
                            self._isolation, top_xact_isolation))
            self._nested = True
    
        if self._nested:
            self._id = con._get_unique_id('savepoint')
            query = 'SAVEPOINT {};'.format(self._id)
        else:
            query = 'BEGIN'
            if self._isolation == 'read_committed':
                query += ' ISOLATION LEVEL READ COMMITTED'
            elif self._isolation == 'read_uncommitted':
                query += ' ISOLATION LEVEL READ UNCOMMITTED'
            elif self._isolation == 'repeatable_read':
                query += ' ISOLATION LEVEL REPEATABLE READ'
            elif self._isolation == 'serializable':
                query += ' ISOLATION LEVEL SERIALIZABLE'
            if self._readonly:
                query += ' READ ONLY'
            if self._deferrable:
                query += ' DEFERRABLE'
            query += ';'
    
        try:
>           await self._connection.execute(query)

/opt/homebrew/Caskroom/miniconda/base/lib/python3.11/site-packages/asyncpg/transaction.py:146: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <asyncpg.connection.Connection object at 0x119fec8b0>, query = 'BEGIN;'
timeout = None, args = ()

    async def execute(self, query: str, *args, timeout: float=None) -> str:
        """Execute an SQL command (or commands).
    
        This method can execute many SQL commands at once, when no arguments
        are provided.
    
        Example:
    
        .. code-block:: pycon
    
            >>> await con.execute('''
            ...     CREATE TABLE mytab (a int);
            ...     INSERT INTO mytab (a) VALUES (100), (200), (300);
            ... ''')
            INSERT 0 3
    
            >>> await con.execute('''
            ...     INSERT INTO mytab (a) VALUES ($1), ($2)
            ... ''', 10, 20)
            INSERT 0 2
    
        :param args: Query arguments.
        :param float timeout: Optional timeout value in seconds.
        :return str: Status of the last SQL command.
    
        .. versionchanged:: 0.5.4
           Made it possible to pass query arguments.
        """
        self._check_open()
    
        if not args:
            if self._query_loggers:
                with self._time_and_log(query, args, timeout):
                    result = await self._protocol.query(query, timeout)
            else:
>               result = await self._protocol.query(query, timeout)
                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

/opt/homebrew/Caskroom/miniconda/base/lib/python3.11/site-packages/asyncpg/connection.py:350: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   RuntimeError: Task <Task pending name='Task-29' coro=<test_contractor_invalid_api_key() running at /Users/alsmolentsev/tms_new/tests/test_modules_5_10.py:108> cb=[_run_until_complete_cb() at /opt/homebrew/Caskroom/miniconda/base/lib/python3.11/asyncio/base_events.py:181]> got Future <Future pending cb=[Protocol._on_waiter_completed()]> attached to a different loop

asyncpg/protocol/protocol.pyx:374: RuntimeError
----------------------------- Captured stdout call -----------------------------
Exception terminating connection <AdaptedConnection <asyncpg.connection.Connection object at 0x119fec8b0>>
Traceback (most recent call last):
  File "/opt/homebrew/Caskroom/miniconda/base/lib/python3.11/site-packages/sqlalchemy/pool/base.py", line 372, in _close_connection
    self._dialect.do_terminate(connection)
  File "/opt/homebrew/Caskroom/miniconda/base/lib/python3.11/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py", line 1127, in do_terminate
    dbapi_connection.terminate()
  File "/opt/homebrew/Caskroom/miniconda/base/lib/python3.11/site-packages/sqlalchemy/connectors/asyncio.py", line 402, in terminate
    self.await_(asyncio.shield(self._terminate_graceful_close()))  # type: ignore[attr-defined] # noqa: E501
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/opt/homebrew/Caskroom/miniconda/base/lib/python3.11/site-packages/sqlalchemy/util/_concurrency_py3k.py", line 132, in await_only
    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/opt/homebrew/Caskroom/miniconda/base/lib/python3.11/site-packages/sqlalchemy/util/_concurrency_py3k.py", line 196, in greenlet_spawn
    value = await result
            ^^^^^^^^^^^^
  File "/opt/homebrew/Caskroom/miniconda/base/lib/python3.11/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py", line 912, in _terminate_graceful_close
    await self._connection.close(timeout=2)
  File "/opt/homebrew/Caskroom/miniconda/base/lib/python3.11/site-packages/asyncpg/connection.py", line 1467, in close
    await self._protocol.close(timeout)
  File "asyncpg/protocol/protocol.pyx", line 626, in close
  File "asyncpg/protocol/protocol.pyx", line 659, in asyncpg.protocol.protocol.BaseProtocol._request_cancel
  File "/opt/homebrew/Caskroom/miniconda/base/lib/python3.11/site-packages/asyncpg/connection.py", line 1611, in _cancel_current_command
    self._cancellations.add(self._loop.create_task(self._cancel(waiter)))
                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/opt/homebrew/Caskroom/miniconda/base/lib/python3.11/asyncio/base_events.py", line 435, in create_task
    self._check_closed()
  File "/opt/homebrew/Caskroom/miniconda/base/lib/python3.11/asyncio/base_events.py", line 520, in _check_closed
    raise RuntimeError('Event loop is closed')
RuntimeError: Event loop is closed
------------------------------ Captured log call -------------------------------
ERROR    sqlalchemy.pool.impl.AsyncAdaptedQueuePool:base.py:376 Exception terminating connection <AdaptedConnection <asyncpg.connection.Connection object at 0x119fec8b0>>
Traceback (most recent call last):
  File "/opt/homebrew/Caskroom/miniconda/base/lib/python3.11/site-packages/sqlalchemy/pool/base.py", line 372, in _close_connection
    self._dialect.do_terminate(connection)
  File "/opt/homebrew/Caskroom/miniconda/base/lib/python3.11/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py", line 1127, in do_terminate
    dbapi_connection.terminate()
  File "/opt/homebrew/Caskroom/miniconda/base/lib/python3.11/site-packages/sqlalchemy/connectors/asyncio.py", line 402, in terminate
    self.await_(asyncio.shield(self._terminate_graceful_close()))  # type: ignore[attr-defined] # noqa: E501
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/opt/homebrew/Caskroom/miniconda/base/lib/python3.11/site-packages/sqlalchemy/util/_concurrency_py3k.py", line 132, in await_only
    return current.parent.switch(awaitable)  # type: ignore[no-any-return,attr-defined] # noqa: E501
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/opt/homebrew/Caskroom/miniconda/base/lib/python3.11/site-packages/sqlalchemy/util/_concurrency_py3k.py", line 196, in greenlet_spawn
    value = await result
            ^^^^^^^^^^^^
  File "/opt/homebrew/Caskroom/miniconda/base/lib/python3.11/site-packages/sqlalchemy/dialects/postgresql/asyncpg.py", line 912, in _terminate_graceful_close
    await self._connection.close(timeout=2)
  File "/opt/homebrew/Caskroom/miniconda/base/lib/python3.11/site-packages/asyncpg/connection.py", line 1467, in close
    await self._protocol.close(timeout)
  File "asyncpg/protocol/protocol.pyx", line 626, in close
  File "asyncpg/protocol/protocol.pyx", line 659, in asyncpg.protocol.protocol.BaseProtocol._request_cancel
  File "/opt/homebrew/Caskroom/miniconda/base/lib/python3.11/site-packages/asyncpg/connection.py", line 1611, in _cancel_current_command
    self._cancellations.add(self._loop.create_task(self._cancel(waiter)))
                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/opt/homebrew/Caskroom/miniconda/base/lib/python3.11/asyncio/base_events.py", line 435, in create_task
    self._check_closed()
  File "/opt/homebrew/Caskroom/miniconda/base/lib/python3.11/asyncio/base_events.py", line 520, in _check_closed
    raise RuntimeError('Event loop is closed')
RuntimeError: Event loop is closed
=========================== short test summary info ============================
FAILED tests/test_modules_5_10.py::test_contractor_create_order - sqlalchemy....
FAILED tests/test_modules_5_10.py::test_urgent_assignment_logic - pydantic_co...
FAILED tests/test_modules_5_10.py::test_contractor_invalid_api_key - RuntimeE...
============================== 3 failed in 1.35s ===============================
sys:1: RuntimeWarning: coroutine 'Connection._cancel' was never awaited
